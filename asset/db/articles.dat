{ "_id" : { "$oid" : "47986fdc3816398c1de148a3" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>今天给RCP打包测试，遇到了以前的遗留问题，就是打包后配置文件丢失，导致一些功能实现不了，从而用了硬编码实现，今天闲来无事，偶然间把问题解决了。</p>\r\n<p>以前用的配置文件格式是ini的，在查看了几个配置文件都是properties格式能打包进去后，我也把ini改成了properties，竟然成功。</p>\r\n<p>呵呵～爽啊～</p>", "Intro" : "今天给RCP打包测试，遇到了以前的遗留问题，就是打包后配置文件丢失，导致一些功能实现不了，从而用了硬编码实现，今天闲来无事，偶然间把问题解决了。以前用的配置文件格式是ini的，在查看了几个配置文件都是properties格式能打包进去后，我也把ini改成了properties，竟然成功。呵呵～爽啊～", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "RCP打包的问题", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1579 }
{ "_id" : { "$oid" : "4a0108cc3816398c1de148a1" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>空间申请了好久，都没有用它，感觉很浪费，我的地盘我做主，再也不用看别人脸色了！！</p>", "Intro" : "空间申请了好久，都没有用它，感觉很浪费，我的地盘我做主，再也不用看别人脸色了！！", "Photo" : "", "Tags" : [], "Title" : "我的地盘我做主", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1035 }
{ "_id" : { "$oid" : "4a013aa53816398c1de1489f" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "属性 属性描述 \r\nBundle-Activator Bundle 的 Activator类名。 \r\n示例： \r\nBundle-Activator:org.riawork.demo.Activator \r\nBundle-Category Bundle 的分类属性描述。 \r\n示例： \r\nBundle-Category:Opendoc,OSGI \r\nBundle-Classpath Bundle 的 Classpath。 \r\n示例： \r\nBundle-Classpath:/bin,/lib/log4j.jar \r\nBundle-ContactAddress 提供 Bundle的开发商的联系地址。 \r\n示例： \r\nBundle-ContactAddress:ShangHai \r\nBundle-Copyright Bundle 的版权。 \r\nBundle-Description Bundle 的描述信息。 \r\nBundle-DocURL Bundle 的文档 URL 地址。 \r\nBundle-Localization Bundle 的国际化文件。 \r\n示例： \r\nBundle-Localization: OSGI-INF/l10n/bundle \r\nBundle-ManifestVersion 定义 Bundle所遵循的规范的版本 OSGI R3 对应的值为 1，OSGI R4 对应的值为 2。 \r\nBundle-Name Bundle 的有意义的名称。 \r\nBundle-NativeCode Bundle 所引用的 NativeCode 的地址。 \r\nBundle-RequiredExecutionEnvironment Bundle 运行所需要的环境，如可指定为需要 OSGI R3、Java 1.4、Java 1.3 等。 \r\nBundle-SymbolicName Bundle的唯一标识名，可采用类似 java package名的机制来保证唯一性。 \r\nBundle-Up&#100;ateLocation Bundle 更新时连接的 URL 地址。 \r\nBundle-Vendor Bundle 的开发商。 \r\nBundle-Version Bundle 的版本 \r\nDynamicImport-Package Bundle动态引用的 package。 \r\nExport-Package Bundle对外暴露的 package。 \r\nFragment-Host Fragment 类型 Bundle 所属的 Bundle名。 \r\nImport-Package Bundle引用的 package。 \r\nRequire-Bundle Bundle 所需要引用的其他的 Bundle。", "Intro" : "属性 属性描述 <br/>Bundle-Activator Bundle 的 Activator类名。 <br/>示例： <br/>Bundle-Activator:org.riawork.demo.Activator <br/>Bundle-Category Bundle 的分类属性描述。 ", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "MANIFEST.MF 中的 bundle 元数据信息描述", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1430 }
{ "_id" : { "$oid" : "4a0158303816398c1de1489d" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "从插件中获得绝对路径：\r\nActivatorPlugin.getDefault().getStateLocation().makeAbsolute().toFile().getAbsolutePath());\r\n\r\n通过文件得到Project：\r\nIProject project = ((IFile)o).getProject();\r\n\r\n通过文件得到全路径：\r\nString path = ((IFile)o).getLocation().makeAbsolute().toFile().getAbsolutePath();\r\n\r\n得到整个Workspace的根：\r\nIWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\r\n\r\n从根来查找资源：\r\nIResource resource = root.findMember(new Path(containerName));\r\n从Bundle来查找资源：\r\nBundle bundle = Platform.getBundle(pluginId);\r\nURL fullPathString = BundleUtility.find(bundle, filePath);\r\n\r\n得到Appliaction workspace：\r\nPlatform.asLocalURL(PRODUCT_BUNDLE.getEntry(&#34;&#34;)).getPath()).getAbsolutePath();\r\n得到runtimeworkspace：\r\nPlatform.getInstanceLocation().getURL().getPath();\r\n从编辑器来获得编辑文件\r\nIEditorPart editor = ((DefaultEditDomain)(parent.getViewer().getEditDomain())).getEditorPart();\r\nIEditorInput input = editor.getEditorInput();\r\nif(input instanceof IFileEditorInput){\r\nIFile file = ((IFileEditorInput)input).getFile();\r\n}\r\n", "Intro" : "从插件中获得绝对路径：<br/>ActivatorPlugin.getDefault().getStateLocation().makeAbsolute().toFile().getAbsolutePath());<br/><br/>通过文件得到Project：<br/>IProject project = ((IFile)o).getProject();", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "从插件 RCP 中取得文件路径的方法", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1296 }
{ "_id" : { "$oid" : "4a081fda3816398c1de1489b" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>孕期通过B超判断胎儿的发育的大小是较有参考价值的一种方法，孕妇在做B超的时候会看到检查报告上有一些数值，这些数值就是告诉你宝宝的发育大小。</p>\r\n  \r\n<p><b>孕早期胎儿发育的过程及B超所见</b></p>\r\n<p>妊娠是一个复杂的过程，卵子受精后，进入宫腔，胚胎及附属物迅速生长发育直至成熟的过程中，每个孕周都会有不同的变化。在孕早期的各个周里你的小宝宝会是什么样呢，下面的文章会详细告诉你。</p>\r\n<p>孕04周：胎儿只有0.2厘米，受精卵刚完成着床，羊膜腔才形成，体积很小。超声还看不清妊娠迹象。<br/>\r\n孕05周：胎儿长到0.4厘米，进入了胚胎期，羊膜腔扩大，原始心血管出现，可有搏动。B超可看见小胎囊，胎囊约占宫腔不到1/4，或可见胎芽。<br/>\r\n孕06周：胎儿长到0.85厘米，胎儿头部、脑泡、额面器官、呼吸、消化、神经等器官分化，B超胎囊清晰可见，并见胎芽及胎心跳。<br/>\r\n孕07周：胎儿长到1.33厘米，胚胎已具有人雏形，体节已全部分化，四肢分出，各系统进一步发育。B超清楚看到胎芽及胎心跳，胎囊约占宫腔的l／3。<br/>\r\n孕08周：胎儿长到1.66厘米，胎形已定，可分出胎头、体及四肢，胎头大于躯干。B超可见胎囊约占官腔1／2，胎儿形态及胎动清楚可见，并可看见卵黄囊。<br/>\r\n孕09周：胎儿长到2.15厘米，胎儿头大于胎体，各部表现更清晰，头颅开始钙化、胎盘开始发育。B超可见胎囊几乎占满宫腔，胎儿轮廓更清晰，胎盘开始出现。<br/>\r\n孕10周：胎儿长到2.83厘米，胎儿各器官均已形成，胎盘雏形形成。B超可见胎囊开始消失，月芽形胎盘可见，胎儿活跃在羊水中 。<br/>\r\n孕11周：胎儿长到3.62厘米，胎儿各器官进一步发育，胎盘发育。B超可见胎囊完全消失，胎盘清晰可见。<br/>\r\n孕12周：胎儿长到4.58厘米，外生殖器初步发育，如有畸形可以表现，头颅钙化更趋完善。颅骨光环清楚，可测双顶径，明显的畸形可以诊断，此后各脏器趋向完善。</p>\r\n  \r\n<h6><b>孕中期B超检查胎儿发育的正常值</b></h6>\r\n<p>孕期通过B超判断胎儿的发育的大小是较有参考价值的一种方法，孕妇在做B超的时候会看到检查报告上有一些数值，这些数值就是告诉你宝宝的发育大小。要想读懂这些数字，你需要仔细阅读下面的文章。</p>\r\n<p>孕13周：双顶径的平均值为2.52士0.25'腹围的平均值为6.90士l.65'股骨长为1.17士0.31.<br/>\r\n孕14周：双顶径的平均值为2.83士0.57'腹围的平均值为7.77士1.82'股骨长为1.38士0.48.<br/>\r\n孕15周：双顶径的平均值为3.23士0.51'腹围的平均值为9.13士1.56'股骨长为1.74士0.58.<br/>\r\n孕16周：双顶径的平均值为3.62士0.58'腹围的平均值为 10.32士1.92'股骨长为 2.10士0.51.<br/>\r\n孕17周：双顶径的平均值为3.97士0.44'腹围的平均值为11.49士1.62'股骨长为 2.52士0.44.<br/>\r\n孕18周：双顶径的平均值为4.25士0.53'腹围的平均值为12.41士l.89'股骨长为2.71士0.46.<br/>\r\n孕19周：双顶径的平均值为4.52士0.53'腹围的平均值为13.59士2.30'股骨长为3.03士0.50.<br/>\r\n孕20周：双顶径的平均值为4.88士0.58'腹围的平均值为14.80士l.89'股骨长为3.35士O.47.<br/>\r\n孕21周：双顶径的平均值为5.22士0.42'腹围的平均值为15.62士1.84'股骨长为3.64士0.40.<br/>\r\n孕22周：双顶径的平均值为5.45士0.57'腹围的平均值为16.70士2.23'股骨长为3.82士0.47.<br/>\r\n孕23周：双顶径的平均值为5.80士0.44'腹围的平均值为17.90士1.85'股骨长为4.21士0.41.<br/>\r\n孕24周：双顶径的平均值为6.05士0.50'腹围的平均值为18.74士2.23'股骨长为4.36士0.51.<br/>\r\n孕25周：双顶径的平均值为6.39士0.70'腹围的平均值为19.64士2.20'股骨长为4.65士0.42.<br/>\r\n孕26周：双顶径的平均值为6.68士0.61'腹围的平均值为21.62士2.30'股骨长为4.87士O.41.<br/>\r\n孕27周：双顶径的平均值为6.98士0.57'腹围的平均值为21.81士2.12'股骨长为5.10士0.41.<br/>\r\n孕28周：双顶径的平均值为7.24士O.65'腹围的平均值为22.86士2.41'股骨长为5.35士0.55.</p>\r\n  \r\n<h6><b>孕晚期B超检查胎儿发育的正常值</b></h6>\r\n<p>孕晚期的准妈妈一定也想知道你的宝宝发育的是否正常吧，那你一定要读这篇文章，仔细与你做的B超结果对照一下。</p>\r\n<p>孕29周：双顶径的平均值为7.50士0.65，腹围的平均值为：23.71士1.50'股骨长的平均值为5.61士0.44.<br/>\r\n孕30周：双顶径的平均值为7.83士0.62'腹围的平均值为：24.88士2.03'股骨长的平均值为5.77士0.47.<br/>\r\n孕31周：双顶径的平均值为8.06士0.60'腹围的平均值为：25.78士2.32'股骨长的平均值为6.03士0.38.<br/>\r\n孕32周：双顶径的平均值为8.17士0.65'腹围的平均值为：26.20士2.33'股骨长的平均值为6.43士0.49.<br/>\r\n孕33周：双顶径的平均值为8.50士0.47'腹围的平均值为27.78：士2.30'股骨长的平均值为6.42士0.46.<br/>\r\n孕34周：双顶径的平均值为8.61士0.63'腹围的平均值为：27.99士2.55'股骨长的平均值为6.62士0.43.<br/>\r\n孕35周：双顶径的平均值为8.70士0.55'腹围的平均值为：28.74士2.88'股骨长的平均值为6.71士0.45.<br/>\r\n孕36周：双顶径的平均值为8.81士0.57'腹围的平均值为：29.44士2.83'股骨长的平均值为6.95士0.47.<br/>\r\n孕37周：双顶径的平均值为9.00士0.63'腹围的平均值为：30.14士2017'股骨长的平均值为7.10士0.52.<br/>\r\n孕38周：双顶径的平均值为9.08士0.59'腹围的平均值为：30.63士2.83'股骨长的平均值为7.20士0.43.<br/>\r\n孕39周：双顶径的平均值为9.21士0.59'腹围的平均值为：31.34士3.12'股骨长的平均值为7.34士0.53.<br/>\r\n孕40周：双顶径的平均值为9.28士0.50'腹围的平均值为：31.49士2.79'股骨长的平均值为7.4士0.53.</p>\r\n  \r\n<h6><b>怎样看孕期B超检查单</b></h6>\r\n<p>怀孕期间，孕妇将做2-3次的超声波检查，你是不是特别想知道报告单上的各种数字都说明了什么？医院超声检查报告单一般包括以下几方面内容：胎囊、胎头、胎心、胎动、胎盘、股骨、羊水和脊柱。它们各说明什么问题，什么情况下正常，而什么情况下又属异常呢？这里提供一些参考指标：</p>\r\n<ol>\r\n<li>胎囊：胎囊只在怀孕早期见到。它的大小，在孕1.5个月时直径约2厘米，2.5个月时约5厘米为正常。胎囊位置在子宫的宫底、前壁、后壁、上部、中部都属正常；形态圆形、椭圆形、清晰为正常；如胎囊为不规则形、模糊，且位置在下部，孕妇同时有腹痛或阴道流血时，可能要流产。</li>\r\n<li>胎头：轮廓完整为正常，缺损、变形为异常，脑中线无移位和无脑积水为正常。BPD代表胎头双顶径，怀孕到足月时应达到9.3厘米或以上。按一般规律，在孕5个月以后，基本与怀孕月份相符，也就是说，妊娠28周（7个月）时BPD约为7.0厘米，孕32周（8个月）时约为8.0厘米，以此类推。孕8个月以后，平均每周增长约为0.2厘米为正常。</li>\r\n<li>胎心：有、强为正常，无、弱为异常。胎心频率正常为每分钟120-160次之间。</li>\r\n<li>胎动：有、强为正常，无、弱可能胎儿在睡眠中，也可能为异常情况，要结合其他项目综合分析。</li>\r\n<li>胎盘：位置是说明胎盘在子宫壁的位置；胎盘的正常厚度应在2.5-5厘米之间；钙化一项报告单上分为Ⅲ级，Ⅰ级为胎盘成熟的早期阶段，回声均匀，在怀30-32周可见到此种变化；Ⅱ级表示胎盘接近成熟；Ⅲ级提示胎盘已经成熟。越接近足月，胎盘越成熟，回声的不均匀。</li>\r\n<li>股骨长度：是胎儿大腿骨的长度，它的正常值与相应的怀孕月份的BPD值差2-3厘米左右，比如说BPD为9.3厘米，股骨长度应为7.3厘米；BPD为8.9厘米，股骨长度应为6.9厘米等。</li>\r\n<li>羊水：羊水深度在3-7厘米之间为正常，超过7厘米为羊水增多，少于3厘米为羊水减少。</li>\r\n<li>脊椎：胎儿脊柱连续为正常，缺损为异常，可能脊柱有畸形。</li>\r\n<li>脐带：正常情况下，脐带应漂浮在羊水中，如在胎儿颈部见到脐带影像，可能为脐带绕颈。</li>\r\n</ol>", "Intro" : "孕期通过B超判断胎儿的发育的大小是较有参考价值的一种方法，孕妇在做B超的时候会看到检查报告上有一些数值，这些数值就是告诉你宝宝的发育大小。", "Photo" : "", "Tags" : [], "Title" : "孕期B超指标对照表及说明", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 970 }
{ "_id" : { "$oid" : "4a0b8d143816398c1de14899" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>GRASP是General Responsibility Assignment Software patterns（通用职责分配软件模式）的简称，它的核心思想是&amp;ldquo;职责分配（Responsibility Assignment）&amp;rdquo;。GRASP提出了几个基本原则，用来解决面向对象设计的一些问题。</p>\r\n<p>Craig Larman氏在《Applying UML and Patterns》一书中提出了GRASP设计模式的概念。作者称其为设计模式，其实，更好的理解应该为设计原则。因为，与GoF等设计模式不同的是，GoF等设计模式是针对特定问题而提出的解决方法，而GRASP则是站在面向对象设计的角度，告诉我们怎么样设计问题空间中的类与它们的行为责任，以及明确类之间的相互关系等等。GRASP可以说是GoF等设计模式的基础。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><span><strong>GRASP概要</strong></span></span></p>\r\n<p>GRASP是General Responsibility Assignment Software patterns（通用职责分配软件模式）的简称，它的核心思想是&amp;ldquo;职责分配（Responsibility Assignment）&amp;rdquo;，用职责设计对象：&amp;quot;Designing Objects with Responsibilities&amp;quot;。它包含了9个基本模式：<br />\r\n1. <span style=&#34;color: #0000ff&#34;><span><a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=8&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>信息专家(Information expert)</span></span></a></span></span><span style=&#34;color: #0000ff&#34;><br />\r\n</span>2. <span style=&#34;color: #0000ff&#34;><span><a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=9&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>创建者(Creator)</span></span> </a></span></span><br />\r\n3. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=10&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>高内聚(High Cohesion)</span></span></a><br />\r\n4. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=11&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>低耦合(Low coupling)</span></span></a><br />\r\n5. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=12&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>控制器(Controller)</span></span></a><br />\r\n6. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=13&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>多态性(Polymorphism)</span></span></a><br />\r\n7. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=14&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>纯虚构(Pure Fabrication)</span></span></a><br />\r\n8. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=15&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>间接性(Indirection)</span></span></a><br />\r\n9. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=16&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>变化预防(Protected Variations)</span></span></a></p>\r\n<p>GRASP的主要特征：<br />\r\n- 对象职责分配的基本原则。<br />\r\n- 主要应用在分析和建模上。</p>\r\n<p>GRASP的核心思想的理解：<br />\r\n自己干自己的事（职责的分配）<br />\r\n自己干自己的能干的事（职责的分配）<br />\r\n自己只干自己的事（职责的内聚）</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>面向对象设计</strong></span></p>\r\n<p>所谓面向对象设计，就是在系统设计的过程中，通过把系统分成相对独立但又互相联系的对象组合的一种设计方法。<br />\r\n对象具有属性和行为，对象间通过消息进行交互（协作）。</p>\r\n<p><span style=&#34;color: #800000&#34;><strong><span>面向对象设计一般有以下几个关键步骤：</span></strong></span><strong><span style=&#34;color: #993300&#34;><br />\r\n</span></strong><br />\r\n1. 发现对象。找出系统应该由哪些对象构成。<br />\r\n2. 对象的属性。对象具有哪些属性。<br />\r\n3. 对象的行为。对象具有哪些行为，或者说对象需要做什么，它的职责是什么。<br />\r\n4. 对象的关系。对象与对象之间的关系是什么，怎样进行交互，协作等等。<br />\r\n<br />\r\n<span style=&#34;color: #993300&#34;><strong>发现对象</strong></span></p>\r\n<p>对象的发现超出了本文的讨论范围。我们简单地介绍一下对象发现的过程与手段。<br />\r\n一般意义上的对象是现实世界上物体的抽象。也就是说，现实世界里有什么物体，就有什么对象；物体存在什么属性，对象就有什么属性。<br />\r\n我们可以用&amp;ldquo;名词筛选法&amp;rdquo;来发现系统的对象。<br />\r\n比如，一个学生考试成绩管理系统，有以下简单的用例：<br />\r\n- 管理员创建题库（把题条加入题库）<br />\r\n- 系统根据管理员输入的某些条件随机生成试题<br />\r\n- 学生成绩入库与管理<br />\r\n我们可以通过字面意思找出名词，就可以找出&amp;ldquo;管理员&amp;rdquo;，&amp;ldquo;题条&amp;rdquo;，&amp;ldquo;题库&amp;rdquo;，&amp;ldquo;试题&amp;rdquo;，&amp;ldquo;学生&amp;rdquo;，&amp;ldquo;学生成绩&amp;rdquo;等几个对象。</p>\r\n<p>一般通过这种方法（名词筛选法）就可以找出系统的绝大部分对象。<br />\r\n<br />\r\n<span style=&#34;color: #993300&#34;><strong>对象行为</strong></span></p>\r\n<p>行为是对象应该执行的动作，也就是对象的职责。对象具有哪些职责呢？相对于上面所说的&amp;ldquo;名词筛选法&amp;rdquo;，可以简单地用&amp;ldquo;动词筛选法&amp;rdquo;来发现&amp;ldquo;对象的行为&amp;rdquo;。<br />\r\n比如，上面的&amp;ldquo;学生考试成绩管理系统&amp;rdquo;一例中，有&amp;ldquo;创建题库&amp;rdquo;，&amp;ldquo;输入（条件）&amp;rdquo;，&amp;ldquo;生成试题&amp;rdquo;，&amp;ldquo;成绩入库&amp;rdquo;，&amp;ldquo;成绩管理&amp;rdquo;等动词，也就是说，系统的对象至少具有以上这些行为（或职责）。<br />\r\n有时，我们可能还会发现某些&amp;ldquo;行为&amp;rdquo;的粒度过大，这时，可以通过进一步细化用例的描述，来发现更多更细的&amp;ldquo;行为&amp;rdquo;。这里不再详述。</p>\r\n<p>问题1：找出对象的行为（职责）之后，怎么样分配这些行为呢？也就是说怎么确认&amp;ldquo;行为&amp;rdquo;属于哪个对象呢？<br />\r\n<br />\r\n<span style=&#34;color: #993300&#34;><strong>对象关系</strong></span></p>\r\n<p>系统的所有对象不可能是一个个单独存在毫无关系的个体，它们或多或少的有着各种联系（协作关系）。</p>\r\n<p>问题2：如果2个对象之间有协作关系，他们之间最好通过什么样的方式协作呢？</p>\r\n<p>对象扩展特性<br />\r\n<br />\r\n问题3：已经被抽象出来的对象，如何面对将来可能发生的变化呢？</p>\r\n<p>GRASP提出9个基本模式，用于解决以上设计过程中遇到的各种问题。&amp;nbsp;</p>", "Intro" : "<p>GRASP是General Responsibility Assignment Software patterns（通用职责分配软件模式）的简称，它的核心思想是&amp;ldquo;职责分配（Responsibility Assignment）&amp;rdquo;。GRASP提出了几个基本原则，用来解决面向对象设计的一些问题。</p>\r\n<p>Craig Larman氏在《Applying UML and Patterns》一书中提出了GRASP设计模式的概念。作者称其为设计模式，其实，更好的理解应该为设计原则。因为，与GoF等设计模式不同的是，GoF等设计模式是针对特定问题而提出的解决方法，而GRASP则是站在面向对象设计的角度，告诉我们怎么样设计问题空间中的类与它们的行为责任，以及明确类之间的相互关系等等。GRASP可以说是GoF等设计模式的基础。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><span><strong>GRASP概要</strong></span></span></p>\r\n<p>GRASP是General Responsibility Assignment Software patterns（通用职责分配软件模式）的简称，它的核心思想是&amp;ldquo;职责分配（Responsibility Assignment）&amp;rdquo;，用职责设计对象：&amp;quot;Designing Objects with Responsibilities&amp;quot;。它包含了9个基本模式：<br />\r\n1. <span style=&#34;color: #0000ff&#34;><span><a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=8&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>信息专家(Information expert)</span></span></a></span></span><span style=&#34;color: #0000ff&#34;><br />\r\n</span>2. <span style=&#34;color: #0000ff&#34;><span><a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=9&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>创建者(Creator)</span></span> </a></span></span><br />\r\n3. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=10&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>高内聚(High Cohesion)</span></span></a><br />\r\n4. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=11&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>低耦合(Low coupling)</span></span></a><br />\r\n5. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=12&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>控制器(Controller)</span></span></a><br />\r\n6. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=13&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>多态性(Polymorphism)</span></span></a><br />\r\n7. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=14&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>纯虚构(Pure Fabrication)</span></span></a><br />\r\n8. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=15&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>间接性(Indirection)</span></span></a><br />\r\n9. <a target=&#34;_self&#34; href=&#34;http://www.foreworld.net/default.asp?id=16&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>变化预防(Protected Variations)</span></span></a></p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP设计模式 - 概要篇", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1592 }
{ "_id" : { "$oid" : "4a0b8f733816398c1de14897" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>信息专家模式（Information Expert）是GRASP模式中解决类的职责分配问题的最基本的模式。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：<br />\r\n</strong></span><br />\r\n当我们为系统发现完对象和职责之后，职责的分配原则（职责将分配给哪个对象执行）是什么？<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>解决方案：</strong></span><br />\r\n<br />\r\n职责的执行需要某些信息（information），把职责分配给该信息的拥有者。<br />\r\n换句话说，某项职责的执行需要某些资源，只有拥有这些资源的对象才有资格执行职责。</p>\r\n<p>这有点类似现实世界的&amp;ldquo;有能者为之&amp;rdquo;的概念。你有建筑知识，可以去执行盖楼的职责；你有法律知识，可以去裁判案件等等。</p>\r\n<p>满足了面向对象设计的封装性的设计，一般情况下都会满足Information Expert模式。因为Information Expert是<br />\r\n对类的属性（信息），以及对类的属性的操作的封装，它符合对象封装性的概念。<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>优点：</strong></span></p>\r\n<p>- 信息的拥有者类同时就是信息的操作者类，可以减少不必要的类之间的关联。<br />\r\n- 各类的职责单一明确，容易理解。<br />\r\n<br />\r\n<span style=&#34;color: #800000&#34;><strong>Information Expert例<br />\r\n</strong></span><br />\r\n为了说明问题，我们使用&amp;ldquo;学生成绩管理系统&amp;rdquo;中的用例1来说明。<br />\r\n用例1：<br />\r\n- 管理员创建题库（把题条加入题库）<br />\r\n再细化一下：<br />\r\n- 管理员创建题库（把题条加入题库）：如果题库中已经存在所给的题条，则退出，否则加入题条。<br />\r\n这样就存在3个对象：管理员用户User，题条SubjectItem，题库SubjectLibrary<br />\r\n2个职责：判断（新加入的题条是否与题库某题条相等），加入（题条的加入）</p>\r\n<p>这2个职责究竟应该由哪个对象执行？<br />\r\n我们使用Information Expert模式来分析。<br />\r\n1. 判断2个题条是否相等，只要判断题条的ID属性（或其它属性）是否相等就可以了。题条的ID是属于题条的，所以对它的操作应该放在题条SubjectItem里。<br />\r\n2. 题条的加入需要操作的数据有2部分，一部分是新加入的题条本身，另一部分是题库（加入到题库），题条是题库的一部分，所以题条的加入应该放在题库SubjectLibrary里完成。</p>\r\n<p>如图：<br />\r\n<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/z2009514112916.jpg&#34; /><br />\r\n如果把以上2个职责放在第三方类中，无疑增加了它们与第三方类之间的耦合关系。&amp;nbsp;</p>", "Intro" : "<p>信息专家模式（Information Expert）是GRASP模式中解决类的职责分配问题的最基本的模式。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：<br />\r\n</strong></span><br />\r\n当我们为系统发现完对象和职责之后，职责的分配原则（职责将分配给哪个对象执行）是什么？<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>解决方案：</strong></span><br />\r\n<br />\r\n职责的执行需要某些信息（information），把职责分配给该信息的拥有者。<br />\r\n换句话说，某项职责的执行需要某些资源，只有拥有这些资源的对象才有资格执行职责。</p>\r\n<p>这有点类似现实世界的&amp;ldquo;有能者为之&amp;rdquo;的概念。你有建筑知识，可以去执行盖楼的职责；你有法律知识，可以去裁判案件等等。</p>\r\n<p>满足了面向对象设计的封装性的设计，一般情况下都会满足Information Expert模式。因为Information Expert是<br />\r\n对类的属性（信息），以及对类的属性的操作的封装，它符合对象封装性的概念。<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>优点：</strong></span></p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP Information Expert Pattern - Grasp之信息专家模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2037 }
{ "_id" : { "$oid" : "4a0b938e3816398c1de14895" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>创建者模式（Creator）是GRASP模式中解决类的实例的创建职责问题的模式。<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span><br />\r\n<br />\r\n类的实例的创建职责，应该分配给什么样的类？或者说类的实例应该由谁创建？<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>Creator模式所提倡的解决方案：</strong></span></p>\r\n<p>以下条件之一为真的情况，类A的实例的创建职责就分配给类B。<br />\r\n1. B包含A<br />\r\n2. B聚集A<br />\r\n3. B记录A<br />\r\n4. B频繁使用A<br />\r\n5. B有A初始化数据<br />\r\nCreator模式提倡类的实例（对象）创建职责由聚集或包含该对象的对象创建。</p>\r\n<p>注：Creator模式只是一个原则，如果类A，B之间没有包含或聚集关系，应该先考案是否有&amp;ldquo;B记录A&amp;rdquo;，或者&amp;ldquo;B有A初始化数据&amp;rdquo;的关系，然后是&amp;ldquo;B频繁使用A&amp;rdquo;的关系。另外，作为代替方案，一般的采用工厂（Factory）创建方案。</p>\r\n<p>如果不遵循Creator模式，把类的实例的创建职责交给无关的类，类之间的关系变得复杂化，降低系统的可维护性和可扩展性。</p>\r\n<p>一般来说，应用Creator模式，可以从上之下设计好类之间的包含或聚集关系阶层图，让每个类负责创建自己包含的类的实例。<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>应用Creator模式的好处：</strong></span></p>\r\n<p>- 整个结构清晰易懂<br />\r\n- 有利于类或组件的重用<br />\r\n- 防止职责的分散<br />\r\n- 降低耦合性<br />\r\n<br />\r\n<span style=&#34;color: #800000&#34;><span><strong>Creator模式的应用例</strong></span></span><br />\r\n<br />\r\n为了更清楚地说明Creator模式，我们举一个GUI的例子：<br />\r\n有一个用户窗口MainWindow，包含Menu，ToolBar，Dialog等，Dialog上布置有Textbox，Button等元素。<br />\r\n我们应用Creator模式，先为它们设计好具有阶层关系的类图，如下：<br />\r\n<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/j2009514114324.jpg&#34; /><br />\r\n因为MyMenu，MyToolBar，MyDialog由MainWindow所包含，MyTextbox，MyButton被MyDialog包含，MainWindow由Main类调用，<br />\r\n根据Creator模式所提倡的方法，它们的实例的创建职责的分配应该是：<br />\r\nMainWindow的实例由Main创建<br />\r\nMyMenu，MyToolbar，MyDialog的实例由MainWindow创建，<br />\r\nMyTextbox，MyButton的实例由MyDialog创建。</p>\r\n<p>反过来，如果MyMenu，MyToolBar，MyDialog等实例的创建都放在Main类里，那么Main就跟它们产生一种&amp;ldquo;关联&amp;rdquo;关系，如果MyMenu，MyToolBar，MyDialog等发生修改，Main也不得不跟着一起修改，也就是说大大增强了Main类跟它们之间的耦合关系；而Main类本身，也聚集了多余的实例创建功能，降低了Main类的聚合性。</p>", "Intro" : "<p>创建者模式（Creator）是GRASP模式中解决类的实例的创建职责问题的模式。<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span><br />\r\n<br />\r\n类的实例的创建职责，应该分配给什么样的类？或者说类的实例应该由谁创建？<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>Creator模式所提倡的解决方案：</strong></span></p>\r\n<p>以下条件之一为真的情况，类A的实例的创建职责就分配给类B。<br />\r\n1. B包含A<br />\r\n2. B聚集A<br />\r\n3. B记录A<br />\r\n4. B频繁使用A<br />\r\n5. B有A初始化数据<br />\r\nCreator模式提倡类的实例（对象）创建职责由聚集或包含该对象的对象创建。</p>\r\n<p>注：Creator模式只是一个原则，如果类A，B之间没有包含或聚集关系，应该先考案是否有&amp;ldquo;B记录A&amp;rdquo;，或者&amp;ldquo;B有A初始化数据&amp;rdquo;的关系，然后是&amp;ldquo;B频繁使用A&amp;rdquo;的关系。另外，作为代替方案，一般的采用工厂（Factory）创建方案。</p>\r\n<p>如果不遵循Creator模式，把类的实例的创建职责交给无关的类，类之间的关系变得复杂化，降低系统的可维护性和可扩展性。</p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP Creator Pattern - GRASP之创建者模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1447 }
{ "_id" : { "$oid" : "4a0b96453816398c1de14893" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>高内聚模式（High Cohesion）是GRASP模式中为降低类的复杂程度，简化控制而提出的面向对象设计的原则性模式。高内聚（High Cohesion）与低耦合（Low Coupling）模式是GRASP其他模式的根本。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>怎么做才能降低类的复杂程度，简化控制？</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>High Cohesion模式所提倡的解决方案：</strong></span></p>\r\n<p>紧密相关的功能（职责）应该分配给同一个类。</p>\r\n<p>所谓内聚，是指单个物体（类）内部的功能聚集度。比如，只包含有相互关联的功能的类，具有高内聚性，同时，它的外部表现（作用，意图）也就明显；反之，如果一个类由一些不相关的功能构成，它的内聚性就低，它的外部表现就不明显，一方面很难理解它的作用和意图,另一方面,一旦需求变化,扩展性就差。</p>\r\n<p>在现实世界里，高内聚（High Cohesion）表现在&amp;ldquo;各司其职&amp;rdquo;上，也就是说自己只干跟自己相关的工作，别人的工作让别人做。比如，电视机只有信息传播的功能，冰箱只有冷藏冷冻的功能，它们就是一个功能高内聚的个体。为什么不把电视机与冰箱的功能做在一起呢？因为做在一起的话，一方面,只需要电视或冰箱功能的消费者却不得不同时购买它们的整合体，而且消费者如果想换代电视机时，冰箱也只有一起换代;另一方面,如果厂家需要升级电视功能,也不得不考虑怎么整合原来的冰箱功能。也就是说功能低内聚的产品，不利于消费者使用，不利于生产者维护，不利于产品本身的升级换代。<br />\r\n同样，反映到软件设计上，低内聚的类存在使用难，维护升级难的缺点。</p>\r\n<p>高内聚（High Cohesion）与低耦合（Low Coupling）是GRASP模式的核心概念，是其它GRASP模式的根本。<br />\r\n优秀的面向对象设计，一般都遵从[高内聚，低耦合]原则。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>应用High Cohesion模式的好处：</strong></span></p>\r\n<p>- 聚集相关功能，结构清晰，容易理解<br />\r\n- 只聚集相关功能，使得类的职责单一明确，从而降低类的复杂程度，使用简单</p>", "Intro" : "<p>高内聚模式（High Cohesion）是GRASP模式中为降低类的复杂程度，简化控制而提出的面向对象设计的原则性模式。高内聚（High Cohesion）与低耦合（Low Coupling）模式是GRASP其他模式的根本。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>怎么做才能降低类的复杂程度，简化控制？</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>High Cohesion模式所提倡的解决方案：</strong></span></p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP High Cohesion Pattern - GRASP之高内聚模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1802 }
{ "_id" : { "$oid" : "4a0b976d3816398c1de14891" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>低耦合模式（Low Coupling）是GRASP模式中为降低类之间的关联程度，适应可变性而提出的面向对象设计的原则性模式。高内聚（High Cohesion）与低耦合（Low Coupling）模式是GRASP其他模式的根本。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>怎么做才能降低类之间关联程度，能适应需求的变化呢？</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Low Coupling模式所提倡的解决方案：</strong></span></p>\r\n<p>为类分配职责时，应该尽量降低类之间的关联关系（耦合性）。亦即，应该以降低类之间的耦合关系作为职责分配的原则。</p>\r\n<p>所谓耦合，是指多个物体（类）之间的物理或者意思上的关联程度。在面向对象方法中，类是最基本的元素，耦合主要指不同类之间相互关联的紧密程度。面向对象里的关联，主要指一个类对另一个类的调用，聚合（包含），参数传递等关系。<br />\r\n比如，所谓2个关联得非常紧密的类（高耦合），是指其中一个类发生变化（修改）时，另一个类也不得不跟着发生变化（修改）。<br />\r\n面向对象设计要求类之间满足&amp;ldquo;低耦合&amp;rdquo;原则，它是衡量一个设计是否优良的的一个重要标准，因为&amp;ldquo;低耦合&amp;rdquo;有助于使得系统中某一部分的变化对其它部分的影响降到最低程度。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>应用High Cohesion模式的好处：</strong></span></p>\r\n<p>- 独立性，有利于重用。<br />\r\n- 适应需求变化，一旦发生变化时，可以把影响缩小到最小范围。</p>\r\n<p>高内聚（High Cohesion）与低耦合（Low Coupling）是GRASP模式的核心概念，是其它GRASP模式的根本。<br />\r\n优秀的面向对象设计，一般都遵从[高内聚，低耦合]原则。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>内聚与耦合的辩证关系：</strong></span></p>\r\n<p>1，一方面，高内聚要求把紧密关联的功能（职责）聚集在同一个类中，防止功能的扩散和类的无谓增加，从而减少类之间的关联，降低类之间的发生耦合的机率。<br />\r\n2，另一方面，高内聚要求把不相关的功能分散到不同的类，类增加了，势必造成相互关联类的增加，从而增大类之间发生耦合的机率。</p>\r\n<p>面向对象设计，应该考虑效率，实现难度等因素，同时兼顾高内聚（High Cohesion）与低耦合（Low Coupling）性。</p>", "Intro" : "<p>低耦合模式（Low Coupling）是GRASP模式中为降低类之间的关联程度，适应可变性而提出的面向对象设计的原则性模式。高内聚（High Cohesion）与低耦合（Low Coupling）模式是GRASP其他模式的根本。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>怎么做才能降低类之间关联程度，能适应需求的变化呢？</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Low Coupling模式所提倡的解决方案：</strong></span></p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP Low Coupling Pattern - GRASP之低耦合模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1490 }
{ "_id" : { "$oid" : "4a0b9a753816398c1de1488f" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>控制器模式（Controller）是GRASP模式中解决事件处理职责问题的模式。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>在UI层之外，应该由哪个类来处理（控制）系统操作（事件）呢？或者说，当触发一个系统事件时，应该把对事件的处理职责分配给UI层之外的哪个类呢？</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Controller模式所提倡的解决方案：</strong></span></p>\r\n<p>把系统事件的处理职责分配给Controller（控制器）类。<br />\r\n担当Controller（控制器）类角色的候补类可能为：<br />\r\n- 系统全体，设备，子系统等的表现类（Facade Controller）<br />\r\n- 系统事件发生的用例的控制类，通常被命名为Handler，Coordinator，Session等（用例或Session的控制器）。整个系统事件都使用同一个控制器。</p>\r\n<p>Controller模式相当于著名的MVC设计模式的C（Controller）部分。<br />\r\n类似于J2EE核心模式中的Front Controller模式（我们会在其它文章中介绍Front Controller模式）。</p>\r\n<p>Controller模式提倡用一个专门的类来处理所有的系统事件。或者说Controller模式把所有系统事件的处理职责分配给一个专门的类集中处理。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>应用Controller模式的好处：</strong></span></p>\r\n<p>应用Controller模式的系统，对系统事件进行集中处理，所以：<br />\r\n- 防止同类职责的分散。满足高内聚，低耦合原则。<br />\r\n- 有利于共通处理（前处理，后处理等）。<br />\r\n- 变化的高适应能力。能够把变化的修改范围控制在最小范围（控制器）之内。<br />\r\n<br />\r\n<strong><span style=&#34;color: #800000&#34;>Controller模式的应用例</span></strong><br />\r\n<br />\r\nMVC模式。</p>", "Intro" : "<p>控制器模式（Controller）是GRASP模式中解决事件处理职责问题的模式。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>在UI层之外，应该由哪个类来处理（控制）系统操作（事件）呢？或者说，当触发一个系统事件时，应该把对事件的处理职责分配给UI层之外的哪个类呢？</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Controller模式所提倡的解决方案：</strong></span></p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP Controller Pattern - GRASP之控制器模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1471 }
{ "_id" : { "$oid" : "4a0baa433816398c1de1488d" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>多态性模式（Polymorphism）是GRASP扩展模式的一种，它通过多态操作把基于类型的可变行为的定义职责分配给行为发生的类。<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>根据类型（类）的不同而发生变化的行为的定义职责，应该分配给谁？</p>\r\n<p>问题比较抽象难懂，我们通过举例来解释一下。<br />\r\n比如物体的移动行为，不同的物体有不同的移动方法，比方说汽车与人的移动方法不一样。<br />\r\n在面向对象设计中，怎么样分配此类行为的定义职责呢？或者说，此类行为应该在哪定义怎么定义呢？</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Polymorphism模式所提倡的解决方案：</strong></span></p>\r\n<p>Polymorphism模式提倡通过多态操作把基于类型的可变行为的定义职责分配给行为发生的类。</p>\r\n<p>又是一个抽象的概念。我们来解释一下。<br />\r\n多态性是面向对象的重要概念之一。所谓多态性，简单地说，就是具有同一接口的不同对象对相同的消息具有不同的行为。或者说同一消息作用于不同的对象，而产生不同的结果。</p>\r\n<p>传统的设计方法，当类型发生变化时，利用条件判断语句对类型进行判断，然后执行不同的行为。<br />\r\nPolymorphism模式把各变化的&amp;ldquo;行为&amp;rdquo;定义职责分别分配给具有相同操作行为界面的通用接口的实现子类，利用多态性适应行为的可变性。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>应用Polymorphism模式的好处：</strong></span></p>\r\n<p>- 避免重复代码<br />\r\n- 避免重复的分歧条件<br />\r\n- 易扩展。只要实现了统一的通用接口，便可实现行为的扩展</p>\r\n<p><strong><span style=&#34;color: #800000&#34;>Polymorphism模式的应用例</span></strong><br />\r\n<br />\r\n上面的例子：物体的移动行为，应用Polymorphism设计模式，它的类图便是：<br />\r\n<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/92009514132511.jpg&#34; /><br />\r\n如果我们需要扩展&amp;ldquo;移动&amp;rdquo;行为，只需简单地创建一个实现IRunner接口的类。</p>", "Intro" : "<p>多态性模式（Polymorphism）是GRASP扩展模式的一种，它通过多态操作把基于类型的可变行为的定义职责分配给行为发生的类。<br />\r\n<br />\r\n<span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>根据类型（类）的不同而发生变化的行为的定义职责，应该分配给谁？</p>\r\n<p>问题比较抽象难懂，我们通过举例来解释一下。<br />\r\n比如物体的移动行为，不同的物体有不同的移动方法，比方说汽车与人的移动方法不一样。<br />\r\n在面向对象设计中，怎么样分配此类行为的定义职责呢？或者说，此类行为应该在哪定义怎么定义呢？</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Polymorphism模式所提倡的解决方案：</strong></span></p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP Polymorphism Pattern - GRASP之多态性模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1402 }
{ "_id" : { "$oid" : "4a0baf553816398c1de1488b" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>纯虚构模式（Pure Fabrication）是GRASP扩展模式之一，它把非问题领域中的职责分配给人工定义的类。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>非问题领域中的职责应该分配给谁？或者说，按照信息专家等模式分配职责时，存在某些不恰当的职责时，应该怎么做？</p>\r\n<p>所谓不恰当的职责，是指难以分配的职责：在保证高内聚，低耦合的条件下，某些职责难以分配给现存的任何问题领域里的类。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Pure Fabrication模式所提倡的解决方案：</strong></span></p>\r\n<p>Pure Fabrication模式提倡把那些非问题领域的职责分配给那些人工生成的或者容易此类职责的概念类。</p>\r\n<p>Domain Class的概念<br />\r\n我们设计对象的时候应该尽量保持与现实世界里的对象一致。这种与现实世界里的对象保持一致的从业务分析中抽象出来的类叫做&amp;ldquo;Domain Class&amp;rdquo;。它相当于上述问题领域里的类。<br />\r\n比如一个简单的用例：用户注册。<br />\r\n用户就是一个&amp;ldquo;Domain Class&amp;rdquo;，它是现实世界里的业务对象。相当于这里的&amp;ldquo;问题领域里的类&amp;rdquo;。<br />\r\n用户注册需要操作数据库，[数据库操作]是系统功能实现的一个必需功能，它不是现实世界里存在的业务对象，它是一个非Domain Class。如果把[数据库操作]看作一个行为职责，它就相当于这里所说���&amp;ldquo;非问题领域里的职责&amp;rdquo;。</p>\r\n<p>一般来说，Domain Class与非Domain Class的功能如果聚集在一个类里，就破坏了&amp;ldquo;高内聚&amp;rdquo;原则。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>应用Pure Fabrication模式的好处：</strong></span></p>\r\n<p>- 高内聚。不必分配问题领域以外的职责给各Domain类，从而保证各Domain类内部功能上的高度聚集性。<br />\r\n- 低耦合。问题领域以外的职责被分配给第三方非Domain类，一方面可以降低各Domain类之间的关联程度，另一方面可以比较漂亮地整合系统的各方面的职责。<br />\r\n- 重用性。各Domain类由于功能上的聚集与关联度的降低，可以更容易地得到重用。</p>\r\n<p><span style=&#34;color: #800000&#34;><strong>Pure Fabrication模式的应用例</strong></span></p>\r\n<p>以上述&amp;ldquo;用户注册&amp;rdquo;的用例为例，对于问题领域里的类&amp;ldquo;用户（User）&amp;rdquo;，如果把&amp;ldquo;数据库操作的职责&amp;rdquo;分配给&amp;ldquo;用户（User）&amp;rdquo;，那么User类的内聚性大大降低。<br />\r\n应用Pure Fabrication模式，应该人工定义一个数据库管理的概念类UserDbr，把数据库操作的功能分配给它完成。<br />\r\n如图：<br />\r\n<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/a2009514134221.jpg&#34; /><br />\r\n如图，分离Domain类User与非Domain类UserDbMgr，User类只保持问题领域中的信息。保证了高内聚性，和易重用性。</p>", "Intro" : "<p>纯虚构模式（Pure Fabrication）是GRASP扩展模式之一，它把非问题领域中的职责分配给人工定义的类。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>非问题领域中的职责应该分配给谁？或者说，按照信息专家等模式分配职责时，存在某些不恰当的职责时，应该怎么做？</p>\r\n<p>所谓不恰当的职责，是指难以分配的职责：在保证高内聚，低耦合的条件下，某些职责难以分配给现存的任何问题领域里的类。</p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP Pure Fabrication Pattern - GRASP之纯虚构模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1577 }
{ "_id" : { "$oid" : "4a0bb2fa3816398c1de14889" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>间接性模式（Indirection）是GRASP模式中解决类的关联问题的模式。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>为了避免类之间的直接关联，应该给什么样的类分配&amp;ldquo;关联&amp;rdquo;责任？</p>\r\n<p><strong><span style=&#34;font-size: 14px&#34;>Indirection模式所提倡的解决方案：</span></strong></p>\r\n<p>当多个类之间存在复杂的消息交互（关联）时，Indirection模式提倡类之间不直接进行消息交互处理（非直接），而是导入第三方类，把责任（多个类之间的关联责任）分配给第三方类，降低类之间的耦合程度。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>应用Indirection模式的好处：</strong></span></p>\r\n<p>- 高内聚。通过把&amp;ldquo;关联&amp;rdquo;的功能分散到第三方类，原来的类可以更加关注自身功能的实现。<br />\r\n- 低耦合。原本关联类之间不直接关联，降低类之间的耦合性。<br />\r\n- 高重用性。第三方类对&amp;ldquo;关联&amp;rdquo;功能的集中处理，与原来的类对自身功能的专注，有利于类的重用。</p>\r\n<p><span style=&#34;color: #800000&#34;><strong>Indirection模式的应用例</strong></span><br />\r\n<br />\r\n应用Indirection模式的一个最好范例是GoF的Mediator（中介者）模式。</p>", "Intro" : "<p>间接性模式（Indirection）是GRASP模式中解决类的关联问题的模式。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>为了避免类之间的直接关联，应该给什么样的类分配&amp;ldquo;关联&amp;rdquo;责任？</p>\r\n<p><strong><span style=&#34;font-size: 14px&#34;>Indirection模式所提倡的解决方案：</span></strong></p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP Indirection Pattern - GRASP之间接性模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1179 }
{ "_id" : { "$oid" : "4a0bb3d53816398c1de14887" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>变化预防模式（Protected Variations）是GRASP扩展模式之一，它设计稳定的接口来应对将来可能发生的变化或其它不安定的因素。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>对存在于系统，子系统，或对象等元素中的各种变化或不安定的因素，为了不产生对其他元素的不利影响，在它们中间应该怎么样分配职责？</p>\r\n<p><strong><span style=&#34;font-size: 14px&#34;>Protected Variations模式所提倡的解决方案：</span></strong></p>\r\n<p>Protected Variations模式提倡在可预测的变化或不安定因素的周围，用稳定的接口来承担职责。</p>\r\n<p>在面向对象设计中，面向接口编程便符合Protected Variations模式的概念。</p>\r\n<p>有人把Protected Variations模式称为Don&#39;t Talk to Strangers（别跟陌生人说话）。因为它跟实现Protected Variations模式的考虑方法一致。<br />\r\nDon&#39;t Talk to Strangers别名Demeter法则:（LoD: the Law of Demeter），它的基本原则是：只跟直接依赖的对象通信（不要耦合没有明显通信需求的2个对象），也就是说2个对象之间，能不关联的就尽量不要关联。</p>\r\n<p>所谓直接依赖的对象，例如有一个对象A，跟它直接依赖的对象有：<br />\r\n1，A对象本身<br />\r\n2，A的属性成员对象<br />\r\n3，通过参数传送给A的对象（A的方法里参数）<br />\r\n4，A的方法内部生成的对象</p>\r\n<p>为什么说LoD跟实现Protected Variations模式的考虑方法一致呢？<br />\r\n我们举例来说明。<br />\r\n假如，系统需要实现这样一个功能，把一段字符串保存到文件，打印机等输出设备。<br />\r\n这是一个可变的或者说存在不安定因素的功能需求，因为输出设备除了文件，打印机之外，还可能有数据库，屏幕终端，网络输出流等。<br />\r\n应用Protected Variations模式，我们为其定义一个能实现输出功能的稳定接口IOutputer，而具体的功能在具体的子类中实现，比如打印机输出类PrinterOutputer，数据库输出类DatabaseOutputer，文件输出类FileOutputer等。<br />\r\n使用此&amp;ldquo;输出功能&amp;rdquo;的用户只要知道接口就行了。<br />\r\n也就是说，对于用户来说，用户的直接依赖对象只有父接口IOutputer，至于其子类诸如PrinterOutputer，DatabaseOutputer，FileOutputer等都属于陌生人。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>应用Protected Variations模式的好处：</strong></span></p>\r\n<p>- 提高系统对变化的应对能力。一旦系统的可预见的不安定因素发生变化（比如追加功能等），只需要生成一个已有的稳定接口的实现类就可以了，无需修改原来的类。<br />\r\n- 高内聚。具体的功能在各子类中实现，各类的内部功能具有高度聚集性。<br />\r\n- 低耦合。用户类只跟稳定接口通信，减少了跟其它陌生对象的关联的机会，降低了类之间的耦合性。</p>\r\n<p><span style=&#34;color: #800000&#34;><strong>Protected Variations模式的应用例</strong></span></p>\r\n<p>例：把一段字符串保存到文件，打印机等输出设备。<br />\r\n应用Protected Variations模式的类图：<br />\r\n<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/5200951414143.jpg&#34; /></p>", "Intro" : "<p>变化预防模式（Protected Variations）是GRASP扩展模式之一，它设计稳定的接口来应对将来可能发生的变化或其它不安定的因素。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>问题：</strong></span></p>\r\n<p>对存在于系统，子系统，或对象等元素中的各种变化或不安定的因素，为了不产生对其他元素的不利影响，在它们中间应该怎么样分配职责？</p>\r\n<p><strong><span style=&#34;font-size: 14px&#34;>Protected Variations模式所提倡的解决方案：</span></strong></p>\r\n", "Photo" : "", "Tags" : [], "Title" : "GRASP Protected Variations Pattern - GRASP之变化预防模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1323 }
{ "_id" : { "$oid" : "4a1358133816398c1de14885" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>都备案好几回了，都没成功！</p>\r\n<p>这次备案已经好几天了，还没通过，也懒的写啥了！</p>\r\n<p>继续等待。。。</p>", "Intro" : "都备案好几回了，都没成功！这次备案已经好几天了，还没通过，也懒的写啥了！继续等待。。。", "Photo" : "", "Tags" : [], "Title" : "备案！备案！备案！", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1025 }
{ "_id" : { "$oid" : "4a13a65f3816398c1de14883" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>中午吃饱饭，玩了最后一关，一改往日战绩。花了1个半小时，只丢失了4个core，还是让飞机给带走的，有些大意，防空造少了。</p>\r\n<p><img src='#' alt='图丢了' style='width:200px;height:120px'></p>\r\n<p>打算有时间再次改写历史。。。</p>", "Intro" : "中午吃饱饭，玩了最后一关，一改往日战绩。花了1个半小时，只丢失了4个core，还是让飞机给带走的，有些大意，防空造少了。打算有时间再次改写历史。。。", "Photo" : "", "Tags" : [ "防御阵形", "游戏攻略" ], "Title" : "【防御阵形：觉醒】中午又玩了", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1169 }
{ "_id" : { "$oid" : "4a13c0c83816398c1de14881" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p><a href='https://khfw.ha.chinamobile.com/service/fee/txdd.jsp?linkID=F29704ADE95ECF9C6E000E255853D553'>https://khfw.ha.chinamobile.com/service/fee/txdd.jsp?linkID=F29704ADE95ECF9C6E000E255853D553</a></p>", "Intro" : "https://khfw.ha.chinamobile.com/service/fee/txdd.jsp?linkID=F29704ADE95ECF9C6E000E255853D553", "Photo" : "", "Tags" : [], "Title" : "推荐送话费啦！！", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1019 }
{ "_id" : { "$oid" : "4a14d7783816398c1de1487f" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>靠！！！为啥刚才写的全没了。。。不写了。。。</p>", "Intro" : "靠！！！为啥刚才写的全没了。。。不写了。。。", "Photo" : "", "Tags" : [], "Title" : "昨天给老婆买凉鞋", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1066 }
{ "_id" : { "$oid" : "4a14f2c33816398c1de1487d" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>今天完美打完最后一关，用时比昨天少了许多。采用：机枪塔+减速塔+防空炮+加农炮。</p>\r\n<p>最后一关布阵图：</p>\r\n<p><b>左上</b><br />\r\n<img style=\"width:200px;height:120px\" alt=\"图丢了\" src=\"http://www.foreworld.net/attachments/month_0905/92009521141825.jpg\" /></p>\r\n<p><b>右上</b><br />\r\n<img style=\"width:200px;height:120px\" alt=\"图丢了\" src=\"http://www.foreworld.net/attachments/month_0905/e200952114196.jpg\" /></p>\r\n<p><b>右中</b><br />\r\n<img style=\"width:200px;height:120px\" alt=\"图丢了\" src=\"http://www.foreworld.net/attachments/month_0905/z2009521141934.jpg\" /></p>\r\n<p><b>中</b><br />\r\n<img style=\"width:200px;height:120px\" alt=\"图丢了\" src=\"http://www.foreworld.net/attachments/month_0905/z2009521141957.jpg\" /></p>\r\n<p><b>左下</b><br />\r\n<img style=\"width:200px;height:120px\" alt=\"图丢了\" src=\"http://www.foreworld.net/attachments/month_0905/c2009521142016.jpg\" /></p>\r\n<p><b>右下</b><br />\r\n<img style=\"width:200px;height:120px\" alt=\"图丢了\" src=\"http://www.foreworld.net/attachments/month_0905/o2009521142034.jpg\" /></p>", "Intro" : "今天完美打完最后一关，用时比昨天少了许多。采用：机枪塔+减速塔+防空炮+加农炮。", "Photo" : "", "Tags" : [ "防御阵形", "游戏攻略" ], "Title" : "【防御阵形：觉醒】完美最后一关布阵", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2856 }
{ "_id" : { "$oid" : "4a16401a3816398c1de1487b" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>中午把倒数第二关过了，core一个不丢，最后打完的时候把core旁边的防空拆了，想让core都回来，谁知道游戏早早的结束了。。。</p>\r\n<p><img style='width:200px;height:120px' alt='图丢了' src='http://www.foreworld.net/attachments/month_0905/20090522140256.JPG' /></p>", "Intro" : "中午把倒数第二关过了，core一个不丢，最后打完的时候把core旁边的防空拆了，想让core都回来，谁知道游戏早早的结束了。。。", "Photo" : "", "Tags" : [ "防御阵形", "游戏攻略" ], "Title" : "【防御阵形：觉醒】完美倒数第二关布阵", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2075 }
{ "_id" : { "$oid" : "4a1804893816398c1de14879" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p><a href='http://lopica.sourceforge.net/quick.html'>http://lopica.sourceforge.net/quick.html</a></p>", "Intro" : "http://lopica.sourceforge.net/quick.html", "Photo" : "", "Tags" : [ "WebStart", "JavaWebStart", "JWS", "Eclipse", "RCP" ], "Title" : "JNLP Tags - Quick Reference", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1072 }
{ "_id" : { "$oid" : "4a1805b13816398c1de14877" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p><span style=&#34;color: #ff0000&#34;>本教程针对 Eclipse 3.3 （3.2和3.3是有区别的）</span></p>\r\n<p>使用这个题目，虽然和下面文章题目有些相似，是因为我想不出更好的名字了，所以索性不想了。</p>\r\n<p>实现 JavaWebStart 发布 RCP 程序实际是非常简单的，但对于我来说这个过程是比较漫长的，前前后后研究了N次，也不是我笨，本人自认为还算聪明，悟性较高<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/fckeditor/editor/images/smiley/qq2007/13.gif&#34; />，关键是为啥呢？！记性不好呗！！</p>\r\n<p>自我检讨一下，我这人比较懒，不喜欢写日志，所以在第一次研究成功之后，就把源码什么的放在一边了，又接着研究其它东西了，没有记录起来，等到下次用的时候，都忘了<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/fckeditor/editor/images/smiley/qq2007/11.gif&#34; />，正所谓&amp;ldquo;好记性不如烂笔头！&amp;rdquo;，我下定决心以后经常写写&amp;ldquo;博博&amp;rdquo;什么的！！好了，言归正传！</p>\r\n<p><strong>第一步 学习别人的</strong></p>\r\n<p>先看《<a target=&#34;_blank&#34; href=&#34;http://www.ibm.com/developerworks/cn/opensource/os-ecl-rcpws/index.html&#34;><span style=&#34;background-color: #0000ff&#34;><span style=&#34;color: #ffffff&#34;>使用 WebStart 发布 RCP 应用程序</span></span></a>》</p>\r\n<p>为啥让你先看这个呢？</p>\r\n<p>1. 还是得说我这人比较懒。<br />\r\n2. 人家的内容我在复制粘贴到我的文章不就成了剽窃了，所以我不干。<br />\r\n3. 人家的文章写的是很不错，但是针对的是 Eclipse 3.2。</p>\r\n<p><strong>第二步 完善自己的</strong></p>\r\n<p>1. 使用 keytool 命令生成数字签名：</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>C:\\j2sdk1.4.2_16\\bin\\<span style=&#34;color: #ff0000&#34;>keytool</span> -genkey -alias Foreworld.Net -keypass 123456 -storepass 123456 -keystore Foreworld.Net</div>\r\n<p>2. 打包并进行数字签名：<br />\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp; 这里的区别是需要用 Eclipse 的命令参数方式进行打包，否则打包不成功。<br />\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp; 解决方法：修改 Eclipse&amp;nbsp;3.3 的启动方式，创建一个&amp;nbsp;Eclipse&amp;nbsp;3.3 的快捷方式，在目标中输入：</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>D:\\MyEclipse-6.0M1\\eclipse\\eclipse.exe -vm &amp;quot;C:\\j2sdk1.4.2_16\\bin\\javaw.exe&amp;quot;</div>\r\n<p>\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp; 接下来，双击快捷方式，按照教程开始打包。（<span style=&#34;color: #ff0000&#34;>在此必须注意中文文件名是不能数字签名的，如果项目中有文文件名的必须改成英文，否则会在后面的运行过程中出现无法验证数字签名的问题</span>）<br />\r\n<br />\r\n3. 修改主JNLP文件：</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;<br />\r\n&amp;lt;jnlp spec=&amp;quot;1.0+&amp;quot; <span style=&#34;color: #ff0000&#34;>codebase</span>=&amp;quot;<a href=&#34;http://localhost:8081/jws/&#34;>http://localhost:8081/jws/</a>&amp;quot; href=&amp;quot;rss2.jnlp&amp;quot;&amp;gt; <br />\r\n&amp;nbsp;&amp;lt;information&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;title&amp;gt;RSS聚合浏览器 Ver1.0&amp;lt;/title&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;vendor&amp;gt;黄鑫 <a href=&#34;mailto:foreworld@vip.qq.com&amp;lt;/vendor&#34;>foreworld@vip.qq.com&amp;lt;/vendor</a>&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;homepage href=&amp;quot;<a href=&#34;http://www.foreworld.net/&amp;quot;/&#34;>http://www.foreworld.net/&amp;quot;/</a>&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;description&amp;gt;RSS聚合浏览器 Ver1.0&amp;lt;/description&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;icon href=&amp;quot;icon16x16.gif&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;icon kind=&amp;quot;splash&amp;quot; href=&amp;quot;mylogo.gif&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;offline-allowed/&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;/information&amp;gt;</p>\r\n<p>&amp;nbsp;&amp;lt;security&amp;gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp; &amp;lt;!-- 设置此RCP应用对文件系统进行完全的访问权限 --&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;all-permissions/&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;/security&amp;gt;</p>\r\n<p>&amp;nbsp;&amp;lt;!-- 设置此应用程序的启动类，RCP应用总是由此类来引导启动 --&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;application-desc main-class=&amp;quot;org.eclipse.equinox.launcher.WebStartMain&amp;quot;&amp;gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp; &amp;lt;!--&amp;nbsp; 这里可以设置应用程序启动时所要传递的参数，与eclipse.exe所使用的参数类似 --&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;argument&amp;gt;-nosplash&amp;lt;/argument&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;/application-desc&amp;gt;</p>\r\n<p>&amp;nbsp;&amp;lt;resources&amp;gt;&amp;nbsp; <br />\r\n&amp;nbsp; &amp;lt;!-- 指定此应用程序所使用的JRE版本 --&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;j2se version=&amp;quot;1.4+&amp;quot; /&amp;gt;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp; &amp;lt;!--&amp;nbsp; 指定启动类所在的Jar包，发布RCP应用时总是要下载此Jar包 --&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;jar href=&amp;quot;plugins/org.eclipse.equinox.launcher_1.0.0.v20070606.jar&amp;quot;/&amp;gt;&amp;nbsp; <br />\r\n&amp;nbsp; &amp;lt;!--&amp;nbsp; 这里设置扩展配置文件的地址，对于JWS管理器来说，<br />\r\n&amp;nbsp; 一个扩展配置文件即对应一个库，主应用程序可以使用多个库来完成特定的功能。<br />\r\n&amp;nbsp; 扩展配置文件也是可以再包含扩展配置文件的，即可以递归使用 --&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;extension name=&amp;quot;Foreworld RSS2 Feature&amp;quot; href=&amp;quot;features/<span style=&#34;color: #ff0000&#34;>net.foreworld.rss2.feature_1.0.0.v200905231119.jnlp</span>&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;!--&amp;nbsp; 设置RCP应用启动时所要运行的产品Id，与config.ini中的配置相同 --&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;property name=&amp;quot;osgi.splashPath&amp;quot; value=&amp;quot;platform:/base/plugins/net.foreworld.rss2&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;property name=&amp;quot;eclipse.product&amp;quot; value=&amp;quot;net.foreworld.rss2.product&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;property name=&amp;quot;osgi.bundles&amp;quot; value=&amp;quot;<a href=&#34;mailto:org.eclipse.equinox.common@2:start,org.eclipse.up&#100;ate.configurator@3:start,org.eclipse.core.runtime@start&amp;quot;/&#34;>org.eclipse.equinox.common@2:start,org.eclipse.up&#100;ate.configurator@3:start,org.eclipse.core.runtime@start&amp;quot;/</a>&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;property name=&amp;quot;osgi.bundles.defaultStartLevel&amp;quot; value=&amp;quot;4&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp; <br />\r\n&amp;nbsp; &amp;lt;!--&amp;nbsp; 这里设置RCP应用程序的工作空间目录，与普通RCP应用中config.ini的配置项类似 --&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;property name=&amp;quot;osgi.instance.area&amp;quot; value=&amp;quot;@user.home/RSS聚合浏览器 Ver1.0&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;!--&amp;nbsp; 设置RCP应用的配置文件目录 --&amp;gt;<br />\r\n&amp;nbsp; &amp;lt;property name=&amp;quot;osgi.configuration.area&amp;quot; value=&amp;quot;@user.home/RSS聚合浏览器 Ver1.0&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;/resources&amp;gt;&amp;nbsp; <br />\r\n&amp;lt;/jnlp&amp;gt;</p>\r\n</div>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 其中要修改的地方除了 <span style=&#34;color: #ff0000&#34;>codebase</span> 路径外，还需修改 <span style=&#34;color: #ff0000&#34;>net.foreworld.rss2.feature_1.0.0.v200905231119.jnlp</span> ，将其修改为打包生成的 features 目录下的 jnlp 文件名。</p>\r\n<p>4. 配置好你的 tomcat ，直接点击主 jnlp 文件或者在地址栏里输入 jnlp 路径，就可以运行了。</p>\r\n<p>其他闲话不说，完毕收工。</p>", "Intro" : "<p><span style=&#34;color: #ff0000&#34;>本教程针对 Eclipse 3.3 （3.2和3.3是有区别的）</span></p>\r\n<p>使用这个题目，虽然和下面文章题目有些相似，是因为我想不出更好的名字了，所以索性不想了。</p>\r\n<p>实现 JavaWebStart 发布 RCP 程序实际是非常简单的，但对于我来说这个过程是比较漫长的，前前后后研究了N次，也不是我笨，本人自认为还算聪明，悟性较高<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/fckeditor/editor/images/smiley/qq2007/13.gif&#34; />，关键是为啥呢？！记性不好呗！！</p>\r\n<p>自我检讨一下，我这人比较懒，不喜欢写日志，所以在第一次研究成功之后，就把源码什么的放在一边了，又接着研究其它东西了，没有记录起来，等到下次用的时候，都忘了<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/fckeditor/editor/images/smiley/qq2007/11.gif&#34; />，正所谓&amp;ldquo;好记性不如烂笔头！&amp;rdquo;，我下定决心以后经常写写&amp;ldquo;博博&amp;rdquo;什么的！！好了，言归正传！</p>\r\n", "Photo" : "", "Tags" : [ "JavaWebStart", "WebStart", "JWS", "Eclipse", "RCP" ], "Title" : "使用 JavaWebStart 发布 Eclipse RCP 应用程序", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2606 }
{ "_id" : { "$oid" : "4a1a447c3816398c1de14875" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>最后一关99波过了，过的比较危险，只保住了1个core，中间造的全是飞弹。看网上说造震荡很容易过，下次试试。</p>\r\n<p><img style=\"width:200px;height:120px\" alt=\"图丢了\" src=\"http://www.foreworld.net/attachments/month_0905/92009521141825.jpg\" /></p>", "Intro" : "最后一关99波过了，过的比较危险，只保住了1个core，中间造的全是飞弹。看网上说造震荡很容易过，下次试试。", "Photo" : "", "Tags" : [ "防御阵形", "游戏攻略" ], "Title" : "【防御阵形：觉醒】最后一关99波", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2884 }
{ "_id" : { "$oid" : "4a1b30743816398c1de14873" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>姐姐：“弟弟，弟弟你好棒，比爸爸还棒！！”</p>\r\n<p>弟弟：“没错，妈妈也是这么说.”</p>\r\n<p>姐姐：“我和爸爸生下你，我才是妈！！”</p>\r\n<p>弟弟：“不是罢，那我们叫她妈妈的那个人是谁啊？”</p>\r\n<p>姐姐：“她是爸爸的妈妈！”</p>\r\n<p>弟弟：“她不是爸爸的姐姐吗？？”</p>\r\n<p>姐姐：“她是爸爸的姐姐，也是爸爸的妈妈，就像我们俩的关系一样！”</p>\r\n<p>弟弟：“………………”</p>", "Intro" : "姐姐：“弟弟，弟弟你好棒，比爸爸还棒！！”", "Photo" : "", "Tags" : [], "Title" : "日本家庭乱伦经典", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1511 }
{ "_id" : { "$oid" : "4a1b31253816398c1de14871" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>女人有两个优点，但有一个漏洞。</p>\r\n<p>男人虽然没有优点，却有一个长处。</p>\r\n<p>男人经常抓住女人的两个优点，用自己的长处弥补女人的漏洞，这叫天衣无缝。</p>\r\n<p>男人为何聪明？</p>\r\n<p>男人有两个头，女人为何爱吃？</p>\r\n<p>女人有两张嘴，男女为何结婚？</p>\r\n<p>男人想通了，女人想开了，又为何离婚？</p>\r\n<p>男人知道深浅了，女人知道长短了。</p>\r\n<p>营养学家研究婚后男人发胖而女人瘦的原因：</p>\r\n<p>男人每晚有两袋鲜奶，一个燕窝，两个鲍鱼片；而女人每晚只有一根火腿肠，两个鹌鹑蛋。</p>\r\n<p>男人是牛，女人是地，没有耕坏的地，只有累死的牛；牛越耕越瘦，地越耕越熟。</p>\r\n<p>好火费碳，好女费汉，男人要性福，更应要性命。</p>\r\n<p>好兄弟，保重身体啊！！！</p>", "Intro" : "女人有两个优点，但有一个漏洞。", "Photo" : "", "Tags" : [], "Title" : "这样描述男人女人", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 933 }
{ "_id" : { "$oid" : "4a1b347d3816398c1de1486f" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>有时候需要引用其它插件的图标，比如，有一个插件叫: net.foreworld.rss2，它的 icons 目录下有 file.gif 图，如果想引用此图标，在另一个插件的 plugin.xml 中，修改 xml 代码：</p>\r\n\r\n<div class=\"highlight\">\r\n  <pre>\r\n    <code class=\"html\"><span class=\"nt\">&lt;editor</span> <span class=\"na\">icon=</span><span class=\"s\">\"platform:/plugin/net.foreworld.rss2/icons/file.gif\"</span> <span class=\"nt\">/&gt;</span>\r\n</code></pre></div>", "Intro" : "有时候需要引用其它插件的图标，比如，有一个插件叫: net.foreworld.rss2，它的 icons 目录下有 file.gif 图，如果想引用此图标，在另一个插件的 plugin.xml 中，修改 xml 代码...", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "引用其它插件的图标", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1040 }
{ "_id" : { "$oid" : "4a1b38af3816398c1de1486d" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>参考了filearranger项目，设置 Fast View Bar 显示位置，方法如下：</p>\r\n<div class=\"highlight\"><pre><code class=\"js\"><span class=\"k\">public</span> <span class=\"k\">class</span> ApplicationWorkbenchWindowAdvisor {\r\n  <span class=\"k\">public</span> <span class=\"k\">void</span> preWindowOpen() {\r\n    PlatformUI.getPreferenceStore().putValue(\r\n      IWorkbenchPreferenceConstants.INITIAL_FAST_VIEW_BAR_LOCATION,\r\n      IWorkbenchPreferenceConstants.RIGHT);\r\n  }\r\n}</code></pre></div>", "Intro" : "参考了filearranger项目，设置 Fast View Bar 显示位置，方法如下：ApplicationWorkbenchWindowAdvisor.preWindowOpen();", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "设置 Fast View Bar 显示位置", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1409 }
{ "_id" : { "$oid" : "4a1b3b583816398c1de1486b" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>---------------------------<br />\r\nExamples<br />\r\n---------------------------<br />\r\nThe Examples executable launcher was unable to locate its companion shared library.<br />\r\n---------------------------<br />\r\n确定&amp;nbsp;&amp;nbsp; <br />\r\n---------------------------<br />\r\n在 feature.xml 中加入 o&#114;g.eclipse.equinox.launcher.win32.win32.x86_x.x.x 目录和 o&#114;g.eclipse.equinox.launcher_x.x.x.jar 就OK了。</p>", "Intro" : "<p>---------------------------<br />\r\nExamples<br />\r\n---------------------------<br />\r\nThe Examples executable launcher was unable to locate its companion shared library.<br />\r\n---------------------------<br />\r\n确定&amp;nbsp;&amp;nbsp; <br />\r\n---------------------------<br />\r\n在 feature.xml 中加入 o&#114;g.eclipse.equinox.launcher.win32.win32.x86_x.x.x 目录和 o&#114;g.eclipse.equinox.launcher_x.x.x.jar 就OK了。</p>", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "RCP 程序打包错误解决", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1561 }
{ "_id" : { "$oid" : "4a1d08e53816398c1de14869" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p><strong>创建型模式</strong></p>\r\n<p>1. FACTORY&amp;mdash;追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说&amp;ldquo;来四个鸡翅&amp;rdquo;就行了。麦当劳和肯德基就是生产鸡翅的Factory。</p>\r\n<p>工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>\r\n<p>2. BUILDER&amp;mdash;MM最爱听的就是&amp;ldquo;我爱你&amp;rdquo;这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出&amp;ldquo;我爱你&amp;rdquo;这句话了，国外的MM也可以轻松搞掂，这就是我的&amp;ldquo;我爱你&amp;rdquo;builder（这一定比美军在伊拉克用的翻译机好卖）。</p>\r\n<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>\r\n<p>3. FACTORY METHOD&amp;mdash;请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说&amp;ldquo;要一个汉堡&amp;rdquo;，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。</p>\r\n<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>\r\n<p>4. PROTOTYPE&amp;mdash;跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了（100块钱一份，你要不要）。</p>\r\n<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>\r\n<p>5. SINGLETON&amp;mdash;俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道&amp;ldquo;老公&amp;rdquo;，都是指的同一个人，那就是我（刚才做了个梦啦，哪有这么好的事）。</p>\r\n<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的&amp;ldquo;单一实例&amp;rdquo;的需求时才可使用。</p>\r\n<p><strong>结构型模式</strong></p>\r\n<p>6. ADAPTER&amp;mdash;在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了（也不知道他会不会耍我）。</p>\r\n<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>\r\n<p>7. BRIDGE&amp;mdash;早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我&amp;ldquo;早上碰到MM新做了个发型怎么说&amp;rdquo;这种问题，自己用BRIDGE组合一下不就行了。</p>\r\n<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>\r\n<p>8. COMPOSITE&amp;mdash;Mary今天过生日。&amp;ldquo;我过生日，你要送我一件礼物。&amp;rdquo;&amp;ldquo;嗯，好吧，去商店，你自己挑。&amp;rdquo;&amp;ldquo;这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。&amp;rdquo;&amp;ldquo;喂，买了三件了呀，我只答应送一件礼物的哦。&amp;rdquo;&amp;ldquo;什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。&amp;rdquo;&amp;ldquo;&amp;hellip;&amp;hellip;&amp;rdquo;，MM都会用Composite模式了，你会了没有？</p>\r\n<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>\r\n<p>9. DECORATOR&amp;mdash;Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上&amp;ldquo;最好的的礼物，就是爱你的Fita&amp;rdquo;，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来&amp;hellip;&amp;hellip;，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>\r\n<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>\r\n<p>10. FACADE&amp;mdash;我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。</p>\r\n<p>门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>\r\n<p>11. FLYWEIGHT&amp;mdash;每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。</p>\r\n<p>享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>\r\n<p>12. PROXY&amp;mdash;跟MM在网上聊天，一开头总是&amp;ldquo;hi,你好&amp;rdquo;,&amp;ldquo;你从哪儿来呀？&amp;rdquo;&amp;ldquo;你多大了？&amp;rdquo;&amp;ldquo;身高多少呀？&amp;rdquo;这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>\r\n<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>\r\n<p><strong>行为模式</strong></p>\r\n<p>13. CHAIN OF RESPONSIBLEITY&amp;mdash;晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上&amp;ldquo;Hi,可以做我的女朋友吗？如果不愿意请向前传&amp;rdquo;，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!</p>\r\n<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>\r\n<p>14. COMMAND&amp;mdash;俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：&amp;ldquo;我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。&amp;rdquo;</p>\r\n<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>\r\n<p>15. INTERPRETER&amp;mdash;俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。</p>\r\n<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>\r\n<p>16. ITERATOR&amp;mdash;我爱上了Mary，不顾一切的向她求婚。</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Mary：&amp;ldquo;想要我跟你结婚，得答应我的条件&amp;rdquo;</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我：&amp;ldquo;什么条件我都答应，你说吧&amp;rdquo;</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Mary：&amp;ldquo;我看上了那个一克拉的钻石&amp;rdquo;</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我：&amp;ldquo;我买，我买，还有吗？&amp;rdquo;</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Mary：&amp;ldquo;我看上了湖边的那栋别墅&amp;rdquo;</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我：&amp;ldquo;我买，我买，还有吗？&amp;rdquo;</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Mary：&amp;ldquo;你的小弟弟必须要有50cm长&amp;rdquo;</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我脑袋嗡的一声，坐在椅子上，一咬牙：&amp;ldquo;我剪，我剪，还有吗？&amp;rdquo;</p>\r\n<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;hellip;&amp;hellip;</p>\r\n<p>迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>\r\n<p>17. MEDIATOR&amp;mdash;四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>\r\n<p>调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>\r\n<p>18. MEMENTO&amp;mdash;同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>\r\n<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>\r\n<p>19. OBSERVER&amp;mdash;想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>\r\n<p>观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>\r\n<p>20. STATE&amp;mdash;跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说&amp;ldquo;有事情啦&amp;rdquo;，对你不讨厌但还没喜欢上的MM就会说&amp;ldquo;好啊，不过可以带上我同事么？&amp;rdquo;，已经喜欢上你的MM就会说&amp;ldquo;几点钟？看完电影再去泡吧怎么样？&amp;rdquo;，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。</p>\r\n<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>\r\n<p>21. STRATEGY&amp;mdash;跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。</p>\r\n<p>策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>\r\n<p>22. TEMPLATE METHOD&amp;mdash;看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦（具体实现）。</p>\r\n<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>\r\n<p>23. VISITOR&amp;mdash;情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了。</p>\r\n<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>", "Intro" : "<p><strong>创建型模式</strong></p>\r\n<p>1. FACTORY&amp;mdash;追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说&amp;ldquo;来四个鸡翅&amp;rdquo;就行了。麦当劳和肯德基就是生产鸡翅的Factory。</p>\r\n<p>工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>\r\n<p>2. BUILDER&amp;mdash;MM最爱听的就是&amp;ldquo;我爱你&amp;rdquo;这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出&amp;ldquo;我爱你&amp;rdquo;这句话了，国外的MM也可以轻松搞掂，这就是我的&amp;ldquo;我爱你&amp;rdquo;builder（这一定比美军在伊拉克用的翻译机好卖）。</p>\r\n", "Photo" : "", "Tags" : [ "设计模式" ], "Title" : "追MM与设计模式（java的23种设计模式）", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1042 }
{ "_id" : { "$oid" : "4a2001683816398c1de14867" }, "Bookmark" : 0, "Cate" : "设计模式", "Content" : "<p>Singleton模式也叫单态模式，是由GoF提出的23种设计模式中的一种。Singleton模式是一种对象创建型模式，它为一个类生成唯一的实例对象，并提供一个对该实例的全局访问方法。</p>\r\n<p>本文介绍设计模式中的单态（Singleton）模式的概念，用法，以及实际应用中怎么样使用Singleton模式进行开发。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Singleton的概念</strong></span></p>\r\n<p>Singleton模式是一种对象创建型模式，使用Singleton模式，可以保证为一个类只生成唯一的实例对象。也就是说，在整个程序空间中，该类只存在一个实例对象。<br />\r\n其实，GoF对Singleton模式的定义是：保证一个类只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。</p>\r\n<p><span style=&#34;color: #800000&#34;><strong>UML类图</strong></span><br />\r\n&amp;nbsp;<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/Foreworld.Net_20090529233952.jpg&#34; /><br />\r\n<span style=&#34;font-size: 14px&#34;><strong>为什么要使用Singleton模式呢？</strong></span></p>\r\n<p>在应用系统开发中，我们常常有以下需求：</p>\r\n<p>- 在多个线程之间，比如servlet环境，共享同一个资源或者操作同一个对象<br />\r\n- 在整个程序空间使用全局变量，共享资源<br />\r\n- 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等</p>\r\n<p>因为Singleton模式可以保证为一个类只生成唯一的实例对象，所以这些情况，Singleton模式就派上用场了。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Singleton模式的实现</strong></span></p>\r\n<p>Singleton模式是设计模式中相对比较简单的模式之一。理解以及使用方法都比较简单。<br />\r\nSingleton模式有多个实现方法。但目前，每一种都存在或多或少的问题。</p>\r\n<p>下面我们将给出几种实现方法，同时对它们加以比较。</p>\r\n<p><span style=&#34;color: #800000&#34;><strong>第一种方法：</strong></span></p>\r\n<p>这是一种最简单的实现方法。但是一种相对有效的实现方法。现在，一般推荐这一种方法作为Singleton模式的实现方法。</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>package net.foreworld.design.pattern.singleton;</p>\r\n<p>/**<br />\r\n&amp;nbsp;* 单例模式第一种，类定义final放置子类继承<br />\r\n&amp;nbsp;* @author hx<br />\r\n&amp;nbsp;*<br />\r\n&amp;nbsp;*/<br />\r\npublic final class Singleton1 {</p>\r\n<p>&amp;nbsp;//自身唯一实例<br />\r\n&amp;nbsp;private static final Singleton1 instance = new Singleton1();<br />\r\n&amp;nbsp;<br />\r\n&amp;nbsp;/*<br />\r\n&amp;nbsp; * 防止外部创建新实例<br />\r\n&amp;nbsp; */<br />\r\n&amp;nbsp;private Singleton1(){} <br />\r\n&amp;nbsp;<br />\r\n&amp;nbsp;/*<br />\r\n&amp;nbsp; * 提供唯一实例的的全局访问点<br />\r\n&amp;nbsp; */<br />\r\n&amp;nbsp;public static final Singleton1 getInstance(){<br />\r\n&amp;nbsp; return instance;<br />\r\n&amp;nbsp;}<br />\r\n}</p>\r\n</div>\r\n<p>我们注意到，这种方法没有对instance=newSingleton()部分作同期化操作，但考虑到Singleton实例的生成只是在最初被调用时才执行一次，如果我们在调用时适当处理一下，比如在程序的统一初期化时（SERVLET环境的情况下可以在容器被初始化时如SevletListener里）调用一下Singleton，就不会存在线程安全问题。</p>\r\n<p><span style=&#34;color: #800000&#34;><strong>第二种方法：</strong></span></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>package net.foreworld.design.pattern.singleton;</p>\r\n<p>public final class Singleton2 {</p>\r\n<p>&amp;nbsp;private static Singleton2 instance;<br />\r\n&amp;nbsp;<br />\r\n&amp;nbsp;private Singleton2(){}<br />\r\n&amp;nbsp;<br />\r\n&amp;nbsp;public static synchronized Singleton2 getInstance(){<br />\r\n&amp;nbsp; if(instance == null){<br />\r\n&amp;nbsp;&amp;nbsp; instance = new Singleton2();<br />\r\n&amp;nbsp; }<br />\r\n&amp;nbsp; return instance;<br />\r\n&amp;nbsp;}<br />\r\n}</p>\r\n</div>\r\n<p>该方法把Singleton实例生成放到了getInstance方法里，同时使用synchronized解决了线程安全问题。<br />\r\n但如果在高并发的应用系统中，大量的线程在调用getInstance时会受到阻塞，系统的性能将受到严重影响。<br />\r\n<br />\r\n<span style=&#34;color: #800000&#34;><strong>第三种方法：</strong></span></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>package net.foreworld.design.pattern.singleton;</p>\r\n<p>public final class Singleton3 {<br />\r\n&amp;nbsp;private static Singleton3 instance;<br />\r\n&amp;nbsp;<br />\r\n&amp;nbsp;private Singleton3(){} <br />\r\n&amp;nbsp;<br />\r\n&amp;nbsp;public static Singleton3 getInstance(){<br />\r\n&amp;nbsp; if(instance == null){<br />\r\n//&amp;nbsp;&amp;nbsp; synchronized(this){&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n//&amp;nbsp;&amp;nbsp;&amp;nbsp; if(instance == null){<br />\r\n//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; instance = new Singleton3();<br />\r\n//&amp;nbsp;&amp;nbsp;&amp;nbsp; }<br />\r\n//&amp;nbsp;&amp;nbsp; }<br />\r\n&amp;nbsp; }<br />\r\n&amp;nbsp; return instance;<br />\r\n&amp;nbsp;}<br />\r\n}</p>\r\n</div>\r\n<p>该方法也叫double-check（双重检查）方法，把线程同步synchronized放到只会被执行一次的同步块里。该方法虽然解消了性能瓶颈问题，但该方法被指出并不是线程安全的（不同步的情况下引用类型不是线程安全的）。<br />\r\n<br />\r\n<span style=&#34;color: #800000&#34;><strong>第四种方法：</strong></span></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>package net.foreworld.design.pattern.singleton;</p>\r\n<p>public final class Singleton4 {<br />\r\n&amp;nbsp;private volatile static Singleton4 instance;<br />\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp; private Singleton4(){}; <br />\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp; public static Singleton4 getInstance(){<br />\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(instance == null){<br />\r\n//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; synchronized(this) {<br />\r\n//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(instance == null){<br />\r\n//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; instance = new Singleton();<br />\r\n//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }<br />\r\n//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }<br />\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }<br />\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return instance;<br />\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp; }<br />\r\n}</p>\r\n</div>\r\n<p>该方法在第三种方法的基础上，为Singletoninstance的定义加上volatile关键字修饰，该方法也被称为double-checkvolatile方法。但该方法却依奈不同的编译器。也就是说，在某些编译环境中，第四种方法也是非线程安全的。</p>", "Intro" : "<p>Singleton模式也叫单态模式，是由GoF提出的23种设计模式中的一种。Singleton模式是一种对象创建型模式，它为一个类生成唯一的实例对象，并提供一个对该实例的全局访问方法。</p>\r\n<p>本文介绍设计模式中的单态（Singleton）模式的概念，用法，以及实际应用中怎么样使用Singleton模式进行开发。</p>\r\n<p><span style=&#34;font-size: 14px&#34;><strong>Singleton的概念</strong></span></p>\r\n<p>Singleton模式是一种对象创建型模式，使用Singleton模式，可以保证为一个类只生成唯一的实例对象。也就是说，在整个程序空间中，该类只存在一个实例对象。<br />\r\n其实，GoF对Singleton模式的定义是：保证一个类只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。</p>\r\n", "Photo" : "", "Tags" : [ "设计模式" ], "Title" : "设计模式之Singleton - 单态模式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1135 }
{ "_id" : { "$oid" : "4a2095a23816398c1de14865" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>今天又玩了一次，这次玩过就不在玩了，99波狂造Concussion(震荡炮) ，轻松过关。<br />\r\n&amp;nbsp;<img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/Foreworld.Net_20090530101207.JPG&#34; /></p>", "Intro" : "<p>今天又玩了一次，这次玩过就不在玩了，99波狂造Concussion(震荡炮) ，轻松过关。</p>", "Photo" : "", "Tags" : [ "防御阵形", "游戏攻略" ], "Title" : "【防御阵形：觉醒】最后一关99波一个不丢", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1812 }
{ "_id" : { "$oid" : "4a2097223816398c1de14863" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p><strong>Gun(机枪塔) 可防空</strong></p>\r\n<p>造价: 100 +200 +400 <br />\r\n伤害: 极低 极低+ 低+ <br />\r\n射程: 3.5 3.75 4 <br />\r\n频率: 随时</p>\r\n<p>特性: <br />\r\n机枪塔价格便宜，围迷宫时是首选堵路工具 <br />\r\n可对地对空，因此可以应付任何敌人 <br />\r\n由于射程不远，且频率为速射的原因，再加上各防塔间的视线遮挡，所以劲量沿路安放，做到利用最大化</p>\r\n<p>特适合对付: 护盾怪</p>\r\n<p><strong>Inferno(火焰塔) 50%燃烧伤害</strong></p>\r\n<p>造价: 150 +300 +600 <br />\r\n伤害: 极低 极低+ 低 <br />\r\n角度: 70 80 90 <br />\r\n射程: 固定2.5 <br />\r\n频率: 随时+持续</p>\r\n<p>特性: <br />\r\n火焰塔射程近且威力小，但可以制造成片伤害，再加上点燃的效果，可以在敌人离开射程后继续造成50%的伤害达一段时间 <br />\r\n特别适合对付成群的小怪 <br />\r\n火焰塔的放置很讲究，沿路安放是肯定的，但放在转角处(直角)比在直路旁要好的多，而且放在外角比内角效率更高</p>\r\n<p>特适合对付: 敌群，快速移动单位 <br />\r\n不适合对付: 护盾怪(50%攻击且无法点燃)，BOSS</p>\r\n<p><strong>Laser(激光塔) 100%燃烧伤害</strong> <br />\r\n<br />\r\n造价: 200 +400 +800 <br />\r\n伤害: 极低+ 低 中 <br />\r\n射程: 固定3.5 <br />\r\n频率: 随时+持续</p>\r\n<p>特性: <br />\r\n激光塔威力不错，且100%燃烧伤害，也就是说离开射程的敌人会持续受到激光塔全部的伤害达一段时间 <br />\r\n但多个激光塔威力的叠加效率很低，找到的官方解释是 所受伤害=开根号(所有激光塔的攻击力叠加) <br />\r\n也就是说两个激光塔同时攻击一个敌人，造成的伤害只有一个塔攻击时的1.414倍，而不是2倍，3个同时攻击更不合算 <br />\r\n幸好激光塔的AI会主动错开攻击不同的敌人，除非射程里只有一个可攻击对象 <br />\r\n要注意，护盾可以完全吸收燃烧伤害，劲量不要把激光塔建在迷宫入口附近，会被刚出现的未破盾的怪鄙视的 <br />\r\n如果地图上有某块区域怪一定会经过，而你又无法放置有效火力覆盖那里，那就在即将进入该区域的地方放置激光塔 <br />\r\n让那些进入所谓&amp;quot;停火区域&amp;quot;的怪继续燃烧</p>\r\n<p>特适合对付: 快速移动单位 <br />\r\n不适合对付: 护盾怪(完全无法伤害)</p>\r\n<p><strong>Temporal(减速塔)</strong> <br />\r\n<br />\r\n造价: 300 +300 +300 <br />\r\n伤害: 无 <br />\r\n射程: 2.5 3.5 4.5 <br />\r\n频率: 低</p>\r\n<p>特性: <br />\r\n还有什么比减速更好的东西，和其他攻击频率高的防塔联合使用效果最佳，而且减速波不受视野影响，因此可以减速各个层面上的怪</p>\r\n<p><strong>Meteor(迫击炮) 20%燃烧伤害</strong> <br />\r\n<br />\r\n造价: 250 +500 +1000 <br />\r\n伤害: 低+ 中 高 <br />\r\n射程: 固定8.5 <br />\r\n频率: 低 低+ 低++</p>\r\n<p>特性: <br />\r\n20%的燃烧伤害，意味着打护盾怪会减少20%的攻击力 <br />\r\n但由于攻击力够高，所以打护盾怪不是大问题，而且可以造成面杀伤，攻击怪群也是不错的 <br />\r\n射程就其一大优点，几乎不受视野影响(放在下层时可能会因地形无法攻击到某些区域)，放在哪里都可以</p>\r\n<p><strong>Cannon(加农炮) 可防空</strong> <br />\r\n<br />\r\n造价: 200 +400 +800 <br />\r\n伤害: 低+ 中- 中 <br />\r\n射程: 5.5 6 6.5 <br />\r\n频率: 低 2连射 3连射</p>\r\n<p>特性: <br />\r\n如果不喜欢使用机枪群的话，加农炮就应该是主力，射程和攻击都很可靠 <br />\r\n特别是升级后不但威力提高，而且还增加炮管，攻击力就更强了 <br />\r\n低发射频率使得视野遮挡对持续伤害输出的影响降低(看不见时正好装弹)，因此放在阵地后排也没问题 <br />\r\n要注意的是，升级后虽然炮管增加了，但还是一次齐射攻击一个敌人，所以对付弱小的群怪时就很废了</p>\r\n<p>特适合对付: 护盾，血牛，BOSS <br />\r\n不适合对付: 敌群，小怪(浪费攻击力)</p>\r\n<p><strong>Tesla(磁暴塔)</strong> <br />\r\n<br />\r\n造价: 175 +350 +700 <br />\r\n伤害: 低+ 中 高- <br />\r\n射程: 固定2.5 <br />\r\n频率: 低+ 低++ 中-</p>\r\n<p>特性: <br />\r\n电击伤害，红警玩多了的人肯定喜欢这东西，但如何用好就是另一回事了 <br />\r\n磁暴塔的攻击频率不高，但可以链式伤害，适合对付群怪 <br />\r\n且磁暴塔可以在不攻击的时候蓄能，对付血牛时也可以造成致命的第一下伤害 <br />\r\n具体数值(摘自Steam论坛，有编辑)</p>\r\n<p>1级磁暴塔，攻击2个敌人，4级蓄能，每3秒增加一个蓄能等级，12秒蓄满 <br />\r\n0级蓄能: 不开火 <br />\r\n1级蓄能: 33 dmg (目标1) + 22 dmg (目标2) <br />\r\n2级蓄能: 49 dmg (目标1) + 33 dmg (目标2) <br />\r\n3级蓄能: 74 dmg (目标1) + 49 dmg (目标2) <br />\r\n4级蓄能: 111 dmg (目标1) + 74 dmg (目标2)</p>\r\n<p>2级磁暴塔，攻击3个敌人，5级蓄能，每2.75秒增加一个蓄能等级，13.75秒蓄满 <br />\r\n0级蓄能: 不开火 <br />\r\n1级蓄能: 58 + 39 + 26 <br />\r\n2级蓄能: 87 + 58 + 39 <br />\r\n3级蓄能: 131 + 87 + 58 <br />\r\n4级蓄能: 196 + 131 + 87 <br />\r\n5级蓄能: 294 + 196 + 131</p>\r\n<p>3级磁暴塔，攻击4个敌人，6级蓄能，每2.5秒增加一个蓄能等级，15秒蓄满 <br />\r\n0级蓄能: 不开火 <br />\r\n1级蓄能: 90 + 60 + 40 + 27 <br />\r\n2级蓄能: 135 + 90 + 60 + 40 <br />\r\n3级蓄能: 203 + 135 + 90 + 60 <br />\r\n4级蓄能: 301 + 203 + 135 + 90 <br />\r\n5级蓄能: 450 + 301 + 203 + 135 <br />\r\n6级蓄能: 675 + 450 + 301 + 203</p>\r\n<p>将磁暴塔放在迷宫靠后方，怪物较少能到达的地方(比如CORE附近，如果你的防线稳固的话)，可以给其充足的时间蓄能 <br />\r\n作为最后一道防线清洗落网之鱼</p>\r\n<p><strong>Missle(导弹塔) 只防空</strong> <br />\r\n<br />\r\n造价: 225 +450 +900 <br />\r\n伤害: 高- 高+ 高++ <br />\r\n射程: 固定8.5 <br />\r\n频率: 中- 2连射 3连射</p>\r\n<p>特性: <br />\r\n纯防空，升到3级后攻击里满了，威力没的说 <br />\r\n每升一级还增加一枚导弹，但和Cannon不同，每颗导弹可以攻击不同的目标 <br />\r\n在空军的路线附近放置两到三个3级导弹塔后基本可以无视飞行单位了</p>\r\n<p>特适合对付: 空军 <br />\r\n不适合对付: 地面单位(被无视了)</p>\r\n<p><br />\r\n<strong>Concussion(震荡炮) <br />\r\n</strong><br />\r\n造价: 275 +550 +1100 <br />\r\n伤害: 极低-- 极低- 极低 <br />\r\n射程: 固定3 <br />\r\n频率: 随时</p>\r\n<p>特性: <br />\r\n射程很近，但可以同时攻击范围内的所有敌人，可以说群伤效果比火焰塔更好，放在U型弯口，特别是能自己铺出来的U型弯效率最高 <br />\r\n而且不属于燃烧伤害，护盾不是问题 <br />\r\n升级后炸弹的密度明显提高了，但攻击力的提高还是有限，和减速塔配合使用对付群怪很有效 <br />\r\n要注意，有种护盾怪可以同时保护周围的敌人，只有打掉其护盾才能解除所有怪的保护 <br />\r\n如果这群敌人进入射程被多枚流弹击中，只会计算一次对护盾的伤害</p>\r\n<p>特适合对付: 群怪 <br />\r\n不适合对付: 被一个护盾怪保护的群怪</p>\r\n<p><strong>Command(控制塔) </strong><br />\r\n<br />\r\n造价: 300 +300 +300 <br />\r\n伤害: 无 <br />\r\n射程: 3.5 4.5 5.5 <br />\r\n频率: 随时</p>\r\n<p>特性: <br />\r\n唯一可以探隐形的塔 <br />\r\n但隐形单位会在近距离被任何塔探到，所以如果你喜欢机枪阵，此塔作用不大 <br />\r\n但如果以榴弹炮和加农炮居多的话此塔是必须的 <br />\r\n而且此塔可以增加玩家的收入，凡是在控制塔范围内被干掉的敌人都会增加回收的资源 <br />\r\n1级+25% 2级+35% 3级+45% <br />\r\n想要得高分，全靠此塔了</p>", "Intro" : "<p><strong>Gun(机枪塔) 可防空</strong></p>\r\n<p>造价: 100 +200 +400 <br />\r\n伤害: 极低 极低+ 低+ <br />\r\n射程: 3.5 3.75 4 <br />\r\n频率: 随时</p>\r\n<p>特性: <br />\r\n机枪塔价格便宜，围迷宫时是首选堵路工具 <br />\r\n可对地对空，因此可以应付任何敌人 <br />\r\n由于射程不远，且频率为速射的原因，再加上各防塔间的视线遮挡，所以劲量沿路安放，做到利用最大化</p>\r\n<p>特适合对付: 护盾怪</p>\r\n", "Photo" : "", "Tags" : [ "防御阵形", "游戏攻略" ], "Title" : "【防御阵形：觉醒】炮台功能介绍", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1324 }
{ "_id" : { "$oid" : "4a20d8953816398c1de14861" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>舔咪咪</p>\r\n<p>你晓得舔咪咪</p>\r\n<p>好像那活儿揩在唇缝里</p>\r\n<p>揩在唇缝里</p>\r\n<p>在哪里</p>\r\n<p>在哪里奸过你</p>\r\n<p>你的箫容这样收吸</p>\r\n<p>我一直想勃起</p>\r\n<p>啊 在梦里</p>\r\n<p>梦里</p>\r\n<p>猛力奸过你</p>\r\n<p>舔咪咪晓得多舔泌</p>\r\n<p>是你</p>\r\n<p>湿你</p>\r\n<p>猛奸的就是你</p>\r\n<p>在哪里</p>\r\n<p>在哪里奸过你</p>\r\n<p>你的箫容这样收吸</p>\r\n<p>我一直想勃起</p>\r\n<p>啊 再猛力</p>", "Intro" : "舔咪咪", "Photo" : "", "Tags" : [], "Title" : "舔咪咪", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1142 }
{ "_id" : { "$oid" : "4a20da333816398c1de1485f" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>在MANIFEST.MF里指定的Bundle-Version时一般是\"1.0.0\"的形式，这样输出的Plug-in文件会是\"net.foreworld.rss2_1.0.0.jar\"。</p>\r\n<p>其实还可以用\"qualifier\"关键子让Eclipse在输出这个Plug-in时在文件名里增加输出时的时间，精确到分。</p>\r\n<p>例如指定Bundle-Version为\"1.0.0.vqualifier\"，则输出的文件名就是\"net.foreworld.rss2_1.0.0.v200905301440.jar\"，这个技巧非常有用，从文件名就能分辨Plug-in的新旧。</p>", "Intro" : "看内容吧", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "让输出的 Plug-in 文件名里包含当前时间 ", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1117 }
{ "_id" : { "$oid" : "4a20dc333816398c1de1485d" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>简简单单的一句代码：</p>\r\n<div class=\"highlight\"><pre><code class=\"js\"><span class=\"c1\">// Bundle 名称</span>\r\nActivator.getDefault().getBundle().getHeaders().get(<span class=\"s1\">\"Bundle-Name\"</span>);</code></pre></div>\r\n<p>Bundle-Name可以替换，参考《<a href=\"http://www.foreworld.net/archive/4a013aa53816398c1de1489f.html\">MANIFEST.MF 中的 bundle 元数据信息描述</a>》</p>", "Intro" : "看内容", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "从 plugin.xml 和 MANIFEST.MF 文件中提取版本信息", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1308 }
{ "_id" : { "$oid" : "4a2100df3816398c1de1485b" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>在Eclipse中有三种机制用来定位插件中的语言环境特定文件：<br />\r\n* 平台核心机制（平台的运行时特定于语言环境的子目录搜索） <br />\r\n* Java 资源束（java.util.ResourceBundl） <br />\r\n* plugin.properties 机制（转换 plugin.xml 文件中的值）</p>\r\n<p>plugin.properties 是其中的一种,用来转换plugin.xml 文件中的值.</p>\r\n<p>如:在plugin.properties文件中有如下内容:&amp;nbsp;</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>org.eclipse.stp.wizards.category.lbl=SOA Tools</div>\r\n<p>&amp;nbsp;在plugin.xml中可以这样引用: %key,key为plugin.properties中值对的键名称</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>&amp;lt;extension<br />\r\n&amp;nbsp;id=&amp;quot;org.eclipse.stp.sc.sca.java.jarbuilder&amp;quot;<br />\r\n&amp;nbsp;name=&amp;quot;%org.eclipse.stp.sc.sca.java.jarbuilder.lbl&amp;quot;<br />\r\n&amp;nbsp;point=&amp;quot;org.eclipse.core.resources.builders&amp;quot;&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;builder hasNature=&amp;quot;true&amp;quot;&amp;gt;<br />\r\n&amp;nbsp;&amp;nbsp;&amp;lt;run class=&amp;quot;org.eclipse.stp.sc.sca.java.builders.JarBuilder&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;/builder&amp;gt;<br />\r\n&amp;lt;/extension&amp;gt;</div>\r\n<p>其中,%org.eclipse.stp.sc.sca.java.jarbuilder.lbl对应的就是plugin.properties中的值: SOA Tools</p>\r\n<p>MANIFEST.MF 文件后面添加上 <span style=&#34;color: #ff0000&#34;>Bundle-Localization: plugin</span><br />\r\n&amp;nbsp;</p>", "Intro" : "<p>在Eclipse中有三种机制用来定位插件中的语言环境特定文件：<br />\r\n* 平台核心机制（平台的运行时特定于语言环境的子目录搜索） <br />\r\n* Java 资源束（java.util.ResourceBundl） <br />\r\n* plugin.properties 机制（转换 plugin.xml 文件中的值）</p>\r\n<p>plugin.properties 是其中的一种,用来转换plugin.xml 文件中的值.</p>\r\n<p>如:在plugin.properties文件中有如下内容:&amp;nbsp;</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>org.eclipse.stp.wizards.category.lbl=SOA Tools</div>\r\n<p>&amp;nbsp;在plugin.xml中可以这样引用: %key,key为plugin.properties中值对的键名称</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>&amp;lt;extension<br />\r\n&amp;nbsp;id=&amp;quot;org.eclipse.stp.sc.sca.java.jarbuilder&amp;quot;<br />\r\n&amp;nbsp;name=&amp;quot;%org.eclipse.stp.sc.sca.java.jarbuilder.lbl&amp;quot;<br />\r\n&amp;nbsp;point=&amp;quot;org.eclipse.core.resources.builders&amp;quot;&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;builder hasNature=&amp;quot;true&amp;quot;&amp;gt;<br />\r\n&amp;nbsp;&amp;nbsp;&amp;lt;run class=&amp;quot;org.eclipse.stp.sc.sca.java.builders.JarBuilder&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;/builder&amp;gt;<br />\r\n&amp;lt;/extension&amp;gt;</div>\r\n", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "plugin.xml 中的 % 的用法", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1506 }
{ "_id" : { "$oid" : "4a21031a3816398c1de14859" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>在一般的RCP应用中，经常要在EclipseRCP的工作台界面出现前，弹出自己的对话框，例如登陆校验框。一般的做法是在Application.run(Objectargs)中，在构造工作台之前启动自己的对话框，这样做的坏处就是RCP的工作台没有启动，与工作台相关的数据，参数没有被初始化。如果在对话框中用到这些数据，就会出现问题。</p>\r\n<p>以下是RCP工作台启动和退出时的方法调用顺序：</p>\r\n<p><b>启动顺序</b></p>\r\n<ol>\r\n<li>WorkbenchAdvisor.initialize 在打开每个窗口时调用该方法。</li>\r\n<li>WorkbenchAdvisor.preStartup 其次执行的就是这个方法，但它的调用是在第一个窗口打开之前。在启动或者恢复期间暂时禁用某些项时，该方法非常有用。</li>\r\n<li>WorkbenchAdvisor.openWindows</li>\r\n<li>WorkbenchAdvisor.createWorkbenchWindowAdvisor</li>\r\n<li>WorkbenchWindowAdvisor.preWindowOpen 在打开每个窗口时调用该方法。</li>\r\n<li>WorkbenchWindowAdvisor.createActionBarAdvisor</li>\r\n<li>WorkbenchWindowAdvisor.postWindowCreate</li>\r\n<li>WorkbenchWindowAdvisor.postWindowOpen 在已经打开一个窗口之后调用该方法，可以使用该方法注册任何窗口监听器。</li>\r\n<li>WorkbenchAdvisor.postStartup 对该方法的调用是执行的第三个操作，它的调用是在第一个窗口打开之后，可以用该方法重新启用 preStartup 方法中临时禁用的项。</li>\r\n</ol>\r\n<p><b>关闭顺序</b></p>\r\n<ol>\r\n<li>WorkbenchWindowAdvisor.preWindowShellClose 在用户关闭窗口外壳时调用该方法。</li>\r\n<li>WorkbenchAdvisor.preShutdown 该方法的调用是在事件循环已经终止，任何窗口尚未关闭之前。</li>\r\n<li>WorkbenchWindowAdvisor.postWindowClose</li>\r\n<li>WorkbenchAdvisor.postShutdown 这是最后一个方法，它在事件循环终止之后被调用。</li>\r\n</ol>\r\n<p>在关闭工作台的时候，如果是点击“退出”菜单，而不是点击右上角的\"X\",则不会执行步骤9。</p>\r\n<p>重写WorkbenchWindowAdvisor.publicvoidpostWindowCreate(),该方法定义了在整个Window被创建好，但是还没有打开前执行的操作，要打开的对话框放在这里是最合适的。</p>\r\n<p>问题是要自己关闭splash，执行Platform.endSplash()。</p>\r\n<p><b>WorkbenchAdvisor 类还包含下列方法：</b></p>\r\n<ol>\r\n<li>WorkbenchAdvisor.fillActionBars 在调用 preWindowOpen 方法之后调用该方法，可以使用它配置窗口的动作栏。</li>\r\n<li>WorkbenchAdvisor.postWindowRestore 在根据以前保存的状态重新创建窗口之后调用该方法。</li>\r\n<li>WorkbenchAdvisor.eventLoopException 可以调用该方法处理事件循环崩溃的异常。</li>\r\n<li>WorkbenchAdvisor.eventLoopIdle 在没有更多的事件需要处理的时候调用该方法。</li>\r\n</ol>", "Intro" : "在一般的RCP应用中，经常要在EclipseRCP的工作台界面出现前，弹出自己的对话框，例如登陆校验框。一般的做法是在Application.run(Objectargs)中，在构造工作台之前启动自己的对话框，这样做的坏处就是RCP的工作台没有启动，与工作台相关的数据，参数没有被初始化。如果在对话框中用到这些数据，就会出现问题。", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "Eclipse RCP 工作台生命周期", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2682 }
{ "_id" : { "$oid" : "4a2105163816398c1de14857" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>软件产品的规模总是越来越大,模块越来越多，如果出现了一点影响到后继开发或者维护的迹象，就要果断的进行重构，将项目及时调整到正常轨道上。开发RCP项目中遇到的典型就是随着插件数量的增多，各个插件之间的依赖性越来越强，这时候如果不进行及时调整，任由其发展下去，等到出现了插件循环依赖，再回过头来整改可就不是那么容易了。很有可能还要影响到相关的业务功能部件。<p>\r\n<p><b>任何软件系统到了一定的规模后，都可能会产生模块间的无序依赖。造成这种后果的原因可以总结为以下几种：</b><p>\r\n<ol>\r\n<li>封装性不好，随意开放公共类或接口给第三方使用。造成客户代码深度依赖于此模块。</li>\r\n<li>各个模块各自为政，没有提取公共的接口到基础模块中，使用此模块功能的代码就必须要依赖于此模块。</li>\r\n<li>没有良好的面向接口编程习惯，直接引用被依赖模块的具体类。</li>\r\n<li>随意使用singleton模式，只图使用方便，不考虑在设计上是否必要。</li>\r\n</ol>\r\n<p><b>对应于Eclipse插件开发，可以理解为：</b><p>\r\n<ol>\r\n<li>在plugin.xml文件的runtime项中，不加限制的开放所有Package的访问权限；或者在开发过程中，没有限制，随需随开，不知不觉中加剧了插件间的依赖程度。而且由于降低的访问的门槛，容易养成编程人员的懒惰思想，不利于提高其设计能力。</li>\r\n<li>开发初期大多是几个人负责一个模块，各个模块间互不干扰的开发，需要访问其他模块是，典型的做法就是让被使用模块提供一个Singleton的类，然后随心所欲的使用其具体类。负责各模块的人很难在公共基础这一问题上达成共识，或者是根本没有考虑到这一点。没有基础模块的归纳总结，随着业务的增大，很容易就造成插件间的循环依赖。</li>\r\n<li>使用别的插件的时候，都是直接使用具体类。对插件全部都是依赖于具体类，而不是依赖于抽象。</li>\r\n</ol>\r\n<p><b>可供选择的解决方案如下：</b><p>\r\n<ol>\r\n<li>构建良好的接口体系，外部插件对本插件的依赖仅限于抽象。</li>\r\n<li>提取公共部件到一个基础插件中，其中包括全项目共享的服务和资源。全部插件都依赖于此基础插件。</li>\r\n<li>插件不依赖于具体提供服务的插件，而是依赖于基础插件，提供服务的插件将服务注册到基础插件中。这样就构建了一个服务注册，获取体系。减轻了各个插件间的依赖程度，降低了服务提供者和服务使用者之间的耦合。此体系可通过扩展点机制实现。</li>\r\n</ol>", "Intro" : "软件产品的规模总是越来越大,模块越来越多，如果出现了一点影响到后继开发或者维护的迹象，就要果断的进行重构，将项目及时调整到正常轨道上。开发RCP项目中遇到的典型就是随着插件数量的增多，各个插件之间的依赖性越来越强，这时候如果不进行及时调整，任由其发展下去，等到出现了插件循环依赖，再回过头来整改可就不是那么容易了。很有可能还要影响到相关的业务功能部件。", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "大型RCP项目降低插件依赖度", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1717 }
{ "_id" : { "$oid" : "4a2107b03816398c1de14855" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>如果需要在plugin.xml中表示回车符，可以这样\"&#x0A;&#x0A;\"来做。</p>", "Intro" : "如果需要在plugin.xml中表示回车符，可以这样\"&#x0A;&#x0A;\"来做。", "Photo" : "", "Tags" : [], "Title" : "plugin.xml 中回车符的表示方法", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1461 }
{ "_id" : { "$oid" : "4a2111393816398c1de14853" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p><img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/Foreworld.Net_20090530185756.jpg&#34; /><br />\r\n从这张图可以一幕了然的看到向导对话框包含了一个向导配置，向导配置包含一或多个向导页，只要向导页的数量&amp;gt;1，向导对话框就自动出现back和next。</p>\r\n<p>下面我们来试一下如何创建向导页：</p>\r\n<p><strong>1. 创建两个向导页</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>NewWizardPage1 extends WizardPage<br />\r\nNewWizardPage2 extends WizardPage</div>\r\n<p>在cr&#101;ateControl方法的最后加上this.setControl(composite);这段代码是必须要加的。</p>\r\n<p><strong>2. 创建向导</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>public class NewWizard extends Wizard{</p>\r\n<p>&amp;nbsp;private NewWizardPage1 page1;<br />\r\n&amp;nbsp;private NewWizardPage1 page2;</p>\r\n<p>&amp;nbsp;public NewWizard(){<br />\r\n&amp;nbsp;&amp;nbsp;this.page1 = new NewWizardPage1 (&amp;quot;page1&amp;quot;);<br />\r\n&amp;nbsp;&amp;nbsp;this.page2 = new NewWizardPage1 (&amp;quot;page2&amp;quot;);<br />\r\n&amp;nbsp;&amp;nbsp;this.addPage(this.page1);<br />\r\n&amp;nbsp;&amp;nbsp;this.addPage(this.page2);<br />\r\n&amp;nbsp;}<br />\r\n}</p>\r\n</div>\r\n<p><strong>3. 创建向导对话框</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>public class NewWizardDialog extends WizardDialog{}</p>\r\n</div>\r\n<p><strong>4. 弹出向导对话框</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>NewWizardDialog wizard = new NewWizardDialog(getSite().getShell(),new NewWizard());<br />\r\nwizard.open();</p>\r\n</div>\r\n<p>就这么简单。</p>", "Intro" : "<p><img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/Foreworld.Net_20090530185756.jpg&#34; /><br />\r\n从这张图可以一幕了然的看到向导对话框包含了一个向导配置，向导配置包含一或多个向导页，只要向导页的数量&amp;gt;1，向导对话框就自动出现back和next。</p>\r\n<p>下面我们来试一下如何创建向导页：</p>\r\n<p><strong>1. 创建两个向导页</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>NewWizardPage1 extends WizardPage<br />\r\nNewWizardPage2 extends WizardPage</div>\r\n<p>在cr&#101;ateControl方法的最后加上this.setControl(composite);这段代码是必须要加的。</p>\r\n", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "RCP中创建向导页wizardpage", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2437 }
{ "_id" : { "$oid" : "4a2112a73816398c1de14851" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p>由于要做RCP的演讲幻灯片，所以今天把RCP的帮助功能研究了一下，对于基本的功能实现暂且不说，因为比较简单，现在对上下文敏感帮助的功能实现做下说明。</p>\r\n<p>对于各种控件，例如窗口、按钮、菜单等，Eclipse提供了上下文敏感帮助。上下文敏感帮助可以为用户提供动态的、弹出式的帮助信息，以提高系统的易用性，用户可以在一个命令按钮上按F1键以获得该按钮的操作信息。</p>\r\n<p><img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/Foreworld.Net_20090530190252.jpg&#34; /></p>\r\n<p><strong>1. 在plugin.xml中添加扩展点</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>&amp;lt;extension<br />\r\n&amp;nbsp;point=&amp;quot;org.eclipse.help.contexts&amp;quot;&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;contexts file=&amp;quot;RssView.xml&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;contexts file=&amp;quot;ChannelTreeView.xml&amp;quot;/&amp;gt;<br />\r\n&amp;lt;/extension&amp;gt;</div>\r\n<p>org.eclipse.help.contexts 指上下文帮助的扩展点<br />\r\ncontexts 指上下文帮助的配置文件。</p>\r\n<p><strong>2. 编写配置文件RssView.xml</strong></p>\r\n<p>根据plugin.xml中的设置，把RssView.xml文件放置在项目的根目录下（和src目录平级）。该文件主要是把帮助信息分门别类，并定义好某项帮助的id、名称、注释和对应的html帮助文件。</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;<br />\r\n&amp;lt;?NLS TYPE=&amp;quot;org.eclipse.help.toc&amp;quot;?&amp;gt;<br />\r\n&amp;lt;contexts&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;context id=&amp;quot;RssView&amp;quot;&amp;gt;<br />\r\n&amp;nbsp;&amp;nbsp;&amp;lt;description&amp;gt;系统功能简介&amp;lt;/description&amp;gt;<br />\r\n&amp;nbsp;&amp;nbsp;&amp;lt;topic label=&amp;quot;商都&amp;quot; href=&amp;quot;<a href=&#34;http://www.zz.ha.cn%22/&#34;>http://www.zz.ha.cn&amp;quot;/</a>&amp;gt;<br />\r\n&amp;nbsp;&amp;nbsp;&amp;lt;topic label=&amp;quot;搜狐&amp;quot; href=&amp;quot;<a href=&#34;http://www.sohu.com%22/&#34;>http://www.sohu.com&amp;quot;/</a>&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;/context&amp;gt;<br />\r\n&amp;lt;/contexts&amp;gt;</div>\r\n<p>id 帮助信息ID标识。（id的值需要和后边的配置一致）<br />\r\ndescription 显示帮助信息时的标题栏文字。<br />\r\nhref 帮助信息子项所对应的帮助文件。<br />\r\nlabel 显示帮助信息时，子项的显示名称。</p>\r\n<p><strong>3. 将帮助信息和界面组件关联起来</strong></p>\r\n<p>将帮助信息和对应的界面组件关联起来，这样当焦点在此组件上时，按F1键才能显示出属于该组件的帮助。</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>IWorkbenchHelpSystem helpSystem = this.getSite().getWorkbenchWindow().getWorkbench().getHelpSystem();<br />\r\nhelpSystem.setHelp(this.viewer.getControl(), Activator.PLUGIN_ID+&amp;quot;.RssView&amp;quot;);</div>\r\n<p>setHelp方法的第一个参数是和上下文帮助关联的组件对象，第二个参数由插件的ID标识（MANIFEST.MF 文件的Bundle-SymbolicName项）和上下文帮助项的Id标识组成。</p>\r\n<p>注意上面的 &amp;quot;.RssView&amp;quot; 和xml中的值一致，别忘了写 &amp;quot;.&amp;quot;。</p>", "Intro" : "<p>由于要做RCP的演讲幻灯片，所以今天把RCP的帮助功能研究了一下，对于基本的功能实现暂且不说，因为比较简单，现在对上下文敏感帮助的功能实现做下说明。</p>\r\n<p>对于各种控件，例如窗口、按钮、菜单等，Eclipse提供了上下文敏感帮助。上下文敏感帮助可以为用户提供动态的、弹出式的帮助信息，以提高系统的易用性，用户可以在一个命令按钮上按F1键以获得该按钮的操作信息。</p>\r\n<p><img alt=&#34;&#34; src=&#34;http://www.foreworld.net/attachments/month_0905/Foreworld.Net_20090530190252.jpg&#34; /></p>\r\n<p><strong>1. 在plugin.xml中添加扩展点</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>&amp;lt;extension<br />\r\n&amp;nbsp;point=&amp;quot;org.eclipse.help.contexts&amp;quot;&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;contexts file=&amp;quot;RssView.xml&amp;quot;/&amp;gt;<br />\r\n&amp;nbsp;&amp;lt;contexts file=&amp;quot;ChannelTreeView.xml&amp;quot;/&amp;gt;<br />\r\n&amp;lt;/extension&amp;gt;</div>\r\n", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "RCP上下文敏感帮助功能实现", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1501 }
{ "_id" : { "$oid" : "4a213aa93816398c1de1484f" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p><strong>1. ApplicationWorkbenchWindowAdvisor.preWindowOpen() 中添加：</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>configurer.setShowCoolBar(true);</div>\r\n<p><strong>&amp;nbsp;2. ApplicationActionBarAdvisor.makeActions() 中添加：</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>this.toggle_CoolbarAction = ActionFactory.TOGGLE_COOLBAR.cr&#101;ate(window);<br />\r\nthis.toggle_CoolbarAction.setText(&amp;quot;工具栏(&amp;amp;T)&amp;quot;);<br />\r\nthis.toggle_CoolbarAction.setChecked(true);<br />\r\nthis.register(this.toggle_CoolbarAction);</div>\r\n<p>&amp;nbsp;</p>", "Intro" : "<p><strong>1. ApplicationWorkbenchWindowAdvisor.preWindowOpen() 中添加：</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>configurer.setShowCoolBar(true);</div>\r\n<p><strong>&amp;nbsp;2. ApplicationActionBarAdvisor.makeActions() 中添加：</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>this.toggle_CoolbarAction = ActionFactory.TOGGLE_COOLBAR.cr&#101;ate(window);<br />\r\nthis.toggle_CoolbarAction.setText(&amp;quot;工具栏(&amp;amp;T)&amp;quot;);<br />\r\nthis.toggle_CoolbarAction.setChecked(true);<br />\r\nthis.register(this.toggle_CoolbarAction);</div>\r\n<p>&amp;nbsp;</p>", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "显示或隐藏工具栏", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1383 }
{ "_id" : { "$oid" : "4a213d183816398c1de1484d" }, "Bookmark" : 0, "Cate" : "插件", "Content" : "<p><strong>1. 创建Del&#101;teRetargetAction类</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>public class Del&#101;teRetargetAction extends RetargetAction {<br />\r\n&amp;nbsp;public Del&#101;teRetargetAction() {<br />\r\n&amp;nbsp;&amp;nbsp;super(IWorkbenchActionConstants.Del&#101;te, &amp;quot;删除(&amp;amp;D)&amp;quot;);<br />\r\n&amp;nbsp;&amp;nbsp;this.setActionDefinitionId(&amp;quot;net.foreworld.rss2.bindings.command.del&#101;te&amp;quot;);<br />\r\n&amp;nbsp;&amp;nbsp;this.setImageDescriptor(Activator.getImageDescriptor(&amp;quot;icons/QuickReader_140.gif&amp;quot;));<br />\r\n&amp;nbsp;}<br />\r\n}</div>\r\n<p><strong>2. ApplicationActionBarAdvisor.makeActions() 中添加</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>this.del&#101;teRetargetAction = new Del&#101;teRetargetAction();<br />\r\nthis.register(this.del&#101;teRetargetAction);<br />\r\nwindow.getPartService().addPartListener(this.del&#101;teRetargetAction);</div>\r\n<p><strong>3. 在你的view中添加钩子</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>actionBars.setGlobalActionHandler(IWorkbenchActionConstants.Del&#101;te, this.del&#101;teAction);</div>\r\n<p>第一个参数指RetargetAction的setActionDefinitionId，第二个指当前视图所用删除Action。</p>\r\n<p>这个功能的确已经实现，如果有哪位看客水平太差不能自己在分析的话，我可不管，可不要骂我哦！这里记录的是几个关键点！为啥不写全些呢，因为我懒呗！我又找到了一个更好的方法来实现！不过可不要就此认为这段代码差了，否则我也不会记在这里！</p>", "Intro" : "<p><strong>1. 创建Del&#101;teRetargetAction类</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>public class Del&#101;teRetargetAction extends RetargetAction {<br />\r\n&amp;nbsp;public Del&#101;teRetargetAction() {<br />\r\n&amp;nbsp;&amp;nbsp;super(IWorkbenchActionConstants.Del&#101;te, &amp;quot;删除(&amp;amp;D)&amp;quot;);<br />\r\n&amp;nbsp;&amp;nbsp;this.setActionDefinitionId(&amp;quot;net.foreworld.rss2.bindings.command.del&#101;te&amp;quot;);<br />\r\n&amp;nbsp;&amp;nbsp;this.setImageDescriptor(Activator.getImageDescriptor(&amp;quot;icons/QuickReader_140.gif&amp;quot;));<br />\r\n&amp;nbsp;}<br />\r\n}</div>\r\n<p><strong>2. ApplicationActionBarAdvisor.makeActions() 中添加</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>this.del&#101;teRetargetAction = new Del&#101;teRetargetAction();<br />\r\nthis.register(this.del&#101;teRetargetAction);<br />\r\nwindow.getPartService().addPartListener(this.del&#101;teRetargetAction);</div>\r\n<p><strong>3. 在你的view中添加钩子</strong></p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>actionBars.setGlobalActionHandler(IWorkbenchActionConstants.Del&#101;te, this.del&#101;teAction);</div>\r\n<p>第一个参数指RetargetAction的setActionDefinitionId，第二个指当前视图所用删除Action。</p>\r\n", "Photo" : "", "Tags" : [ "Eclipse", "RCP" ], "Title" : "RCP 中 RetargetAction 的实现", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1640 }
{ "_id" : { "$oid" : "4a21e2983816398c1de1484b" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>又一位华人名星号召关爱AIDS病人。</p>\r\n<p>又出现了一个帮助AIDS病人的机构。</p>\r\n<p>爱护与体谅AIDS病人成了一种时尚，成立这类机构成了风向导标。</p>\r\n<p>生活在伟大的中华民族下的人们。</p>\r\n<p>从来就不缺少表面的民主与道德光环。</p>\r\n<p>所以拯救AIDS病人、与世界接轨已成自然与习惯。</p>\r\n<p>面对AIDS病人，人们不再惊恐。</p>\r\n<p>社会仿佛无比的宽容，真正的民主似乎已经到来。</p>\r\n<p>&nbsp;</p>\r\n<p>但中国毕竟只是中国，一时间还达不到欧美发达国家的水平。</p>\r\n<p>民主更多的只是面子工程，只是伪装丑陋的面具。</p>\r\n<p>所以，我们能听到枯魂遍野，能看到凄惨成堆，</p>\r\n<p>来自全中国近两亿乙肝人群无助的声音。</p>\r\n<p>无法激起社会公正平等的浪花。</p>\r\n<p>携带乙肝病毒的人儿，已经被社会所抛弃。</p>\r\n<p>社会对AIDS，至少还有一层伪善的面具。</p>\r\n<p>而对乙肝，接近了极限的赤裸裸的残忍。</p>\r\n<p>&nbsp;</p>\r\n<p>悲惨远不仅此。</p>\r\n<p>医院与医生，听起来是绝望的人儿的最后一颗救命草。</p>\r\n<p>事实上却是落井下石的屠杀者。</p>\r\n<p>就是故意不治好你，就是要榨干最后一滴血。</p>\r\n<p>没有血的人儿，请你远离白色的世界，自个儿静静的死去。</p>\r\n<p>乙肝人群已经成为了医院、医生的衣食父母。</p>\r\n<p>忤逆之火在不经意间已经燎原。</p>\r\n<p>&nbsp;</p>\r\n<p>医生都不可信了，生命真的要终结了吗？</p>\r\n<p>有文化，有素质的人儿。</p>\r\n<p>自己学习医学，研究医药。</p>\r\n<p>不为别的，只为拯救自己。</p>\r\n<p>一半信医生，一半信自己。</p>\r\n<p>&nbsp;</p>\r\n<p>才华与工作能力已经毫无意义，存在的也只是空中楼阁。</p>\r\n<p>体检成了这群人永远不可跨越的障碍。</p>\r\n<p>大小三阳已经确定了你不属于公正的世界。</p>\r\n<p>&nbsp;</p>\r\n<p>全社会都在看欧美，都在学欧美。</p>\r\n<p>看的是什么，学的是什么谁能告诉我。</p>\r\n<p>能够确定的是，对乙肝的公正，一丁点也没有学会。</p>\r\n<p>人家视其如平常感冒，而我们视其如猛虎怪兽。</p>\r\n<p>我不崇洋媚外，认为几千年中华文化够享用不尽。</p>\r\n<p>我不封闭自居，外来好的东西一样吸收。</p>\r\n<p>&nbsp;</p>\r\n<p>随着时光的痕迹，让我们追诉到清朝的“天花”。</p>\r\n<p>当时的科学，无法研制出根治的药物。</p>\r\n<p>政府采取非常的政策。</p>\r\n<p>放弃已患病的人儿，其他的做好防范措施。</p>\r\n<p>“天花”随着一个群体的灭绝而灭绝。</p>\r\n<p>难道历史要重演？近两亿的人儿，何时能够绝迹？</p>\r\n<p>20年前没人给我们预防，谁来为我们负责？</p>\r\n<p>&nbsp;</p>\r\n<p>电视里、小说中，常常可以见到逼良为娼。</p>\r\n<p>这样的事情现在现实中很少发生。</p>\r\n<p>假想，付不起昂贵医疗费的人只能够静静的等待死神的到来。</p>\r\n<p>死亡近在咫尺。</p>\r\n<p>无形的压力与彻底的绝望，抢劫、偷窃是没有办法的办法。</p>\r\n<p>死都不怕了，还怕没有自由么。</p>\r\n<p>&nbsp;</p>\r\n<p>工作压力巨大，工作时间长。</p>\r\n<p>表面上看来似乎拒绝病毒携带者是为了其健康考虑。</p>\r\n<p>请我们的老总们深入的，认真的了解下，仔细的分析下。</p>\r\n<p>贵单位的工作是否比国家元首的工作更加繁重，更加有压力。</p>\r\n<p>是否比国家总理的工作更加重要，更加艰巨。</p>\r\n<p>伟大的民主革命战士孙中山先生，最伟大的总理周恩来先生。</p>\r\n<p>你们是否也要因为乙肝而拒之门外。</p>\r\n<p>&nbsp;</p>\r\n<p>一代天王刘德华先生是勇敢的，是坚强的。</p>\r\n<p>顶住压力，以身做则。</p>\r\n<p>给所有乙肝患者树立了一个健康、乐观的形象。</p>\r\n<p>给所有乙肝患者于希望，只要努力，没有做不到的事。</p>\r\n<p>&nbsp;</p>\r\n<p>其实并不那么严重，乙肝只是一种很正常的情况。</p>\r\n<p>只要平常注意饮食与生活规律，与平常人没有丝毫区别。</p>\r\n<p>正如欧美，视存在犹如不存在。</p>\r\n<p>我是小三阳，我是病毒携带者。</p>\r\n<p>异样眼神的人儿，放手来吧。</p>\r\n<p>&nbsp;</p>\r\n<p><b>附录：看了一些朋友的留言，我觉得有必要补充一句。</b></p>\r\n<p>这是一位医生朋友告诉我的：</p>\r\n<p>十年前全中国的医院都在榨性病方面病人的钱。</p>\r\n<p>从N年前开始到现在，全中国的医院都在黑乙肝患者的血。</p>", "Intro" : "又一位华人名星号召关爱AIDS病人。又出现了一个帮助AIDS病人的机构。爱护与体谅AIDS病人成了一种时尚，成立这类机构成了风向导标。生活在伟大的中华民族下的人们。从来就不缺少表面的民主与道德光环。所以拯救AIDS病人、与世界接轨已成自然与习惯。面对AIDS病人，人们不再惊恐。社会仿佛无比的宽容，真正的民主似乎已经到来。", "Photo" : "", "Tags" : [ "乙肝" ], "Title" : "某种意义上乙肝比AIDS更悲", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1072 }
{ "_id" : { "$oid" : "4a21e3913816398c1de14849" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<h5><b>第一套〖胜战计〗</b></h5>\r\n<p>瞒天过海 备周则意怠，常见则不疑。阴在阳之内，不在阳之对。太阳，太阴。</p>\r\n<p>围魏救赵 共敌不如分敌，敌阳不如敌阴。</p>\r\n<p>借刀杀人 敌已明，友未定，引友杀敌。不自出力，以《损》推演。</p>\r\n<p>以逸待劳 困敌之势，不以战。损刚益柔。</p>\r\n<p>趁火打劫 敌之害大，就势取利，刚决柔也。</p>\r\n<p>声东击西 敌志乱萃，不虞。坤下兑上之象，利其不自主而取之。</p> \r\n<h5><b>第二套〖敌战计〗</b></h5>\r\n<p>无中生有 诳也，非诳也，实其所诳也。少阴、太阴、太阳。</p>\r\n<p>暗渡陈仓 示之以动，利其静而有主，“益动而巽”。</p>\r\n<p>隔岸观火 阳乖序乱，阴以待逆。暴戾恣睢，其势自毙。顺以动豫，豫顺以动。</p>\r\n<p>笑里藏刀 信而安之，阴以图之。备而后动，勿使有变。刚中柔外也。</p>\r\n<p>李代桃僵 势必有损，损阴以益阳。</p>\r\n<p>顺手牵羊 微隙在所必乘，微利在所必得。少阴，少阳。</p>\r\n<h5><b>第三套〖攻战计〗</b></h5>\r\n<p>打草惊蛇 疑以叩实，察而后动。复者，阴之媒也。</p>\r\n<p>借尸还魂 有用者，不可借；不能用者，求借。借不能用者而用之。匪我求童蒙，童蒙求我。</p>\r\n<p>调虎离山 待天以困之，用人以诱之，往蹇来返。</p>\r\n<p>欲擒姑纵 逼则反兵，走则减势。紧随勿迫，累其气力，消其斗志，散而后擒，兵不血刃。需，有孚，光。</p>\r\n<p>抛砖引玉 类以诱之，击蒙也。</p>\r\n<p>擒贼擒王 摧其坚，夺其魁，以解其体。龙战于野，其道穷也。</p>\r\n<h5><b>第四套〖混战计〗</b></h5>\r\n<p>釜底抽薪 不敌其力，而消其势，兑下乾上之象。</p>\r\n<p>混水摸鱼 乘其阴乱，利其弱而无主。随，以向晦入宴息。</p>\r\n<p>金蝉脱壳 存其形，完其势；友不疑，敌不动。巽而止蛊。</p>\r\n<p>关门捉贼 小敌困之。剥，不利有攸往。</p>\r\n<p>远交近攻 形禁势格，利从近取，害以远隔。上火下泽。</p>\r\n<p>假道伐虢 两大之间，敌胁以从，我假以势。困，有言不信。</p>\r\n<h5><b>第五套〖并战计〗</b></h5>\r\n<p>偷梁换柱 频更其阵，抽其劲旅，待其自败，而后乘之。曳其轮也。</p>\r\n<p>指桑骂槐 大凌小者，警以诱之。刚中而应，行险而顺。</p>\r\n<p>假痴不癫 宁伪作不知不为，不伪作假知妄为。静不露机，云雷屯也。</p>\r\n<p>上屋抽梯 假之以便，唆之使前，断其援应，陷之死地。遇毒，位不当也。</p>\r\n<p>树上开花 借局布势，力小势大。鸿渐于陆，其羽可以为仪也。</p>\r\n<p>反客为主 乘隙插足，扼其主机，渐之进也。</p>\r\n<h5><b>第六套〖败战计〗</b></h5>\r\n<p>美人计 兵强者，攻其将；将智者，伐其情。将弱兵颓，其势自萎。利用御寇，顺相保也。</p>\r\n<p>空城计 虚者虚之，疑中生疑。刚柔之际，奇而复奇。</p>\r\n<p>反间计 疑中之疑。比之自内，不自失也。</p>\r\n<p>苦肉计 人不自害，受害必真。假真真假，间以得行。童蒙之吉，顺以巽也。</p>\r\n<p>连环计 将多兵众，不可以敌，使其自累，以杀其势。在师中吉，承天宠也。</p>\r\n<p>走为上 全师避敌。左次无咎，未失常也。</p>", "Intro" : "六六三十六，数中有术，术中有数。阴阳燮理，机在其中。机不可设，设则不中。", "Photo" : "", "Tags" : [], "Title" : "三十六计", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1017 }
{ "_id" : { "$oid" : "4a21e4183816398c1de14847" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>尧轻轻地放下手中的碗，已经是连续8天的快食面了，现在闻到那种味道都有反胃的感觉。“你吃不吃面？”向隔壁的房间问，听到的只有游戏的燥乱的音乐声。于是尧把声音放的大些，终于有了回音，一个脆脆的女声：“来一筒！”</p>\r\n<p>天！尧在心底呐喊着，她疯了！自从这个该死的游戏窜入市场后，她——采采就没有离开过那个屏幕，什么家务也不管了，也不挨家挨户去推销保险了，就连最起码的性生活也没有了保障。虽然他们只是同居，但和婚姻也只是一张纸的差别。他有着雄厚的资产，有无数个女子想对他投怀送抱，但他只爱采采。以前也曾经让她在家安心做家庭主妇，可是她总说要靠自己，现在好了，比家庭主妇还要主妇。</p></p>\r\n<p>但现在两个人其实走进了一个怪圈，一个无法走出的怪圈，双方无法交流，无法探讨，但是采采从来不去管这些，她甚至不知道今天是星期几，现在是白天还是黑夜，她只有游戏。</p>\r\n<p>尧终于忍不住了，“你要怎样啊？能不能说说话？就知道玩！”</p>\r\n<p>“说什么啊，有什么说的，啊！老怪来了！”连头都没有回。</p>\r\n<p>尧推门向外走，“我出去了！”</p>\r\n<p>“把门带上！”</p>\r\n<p>“砰”一声，尧呼了一口气，燃了一支烟，他有些怒了，平常从没有动过怒的他真的怒了！径直向网吧走去。</p>\r\n<p>尧在一个有名的BBS是个小有名气的写手，写惯了别人的悲欢离合，写自己时竟然有些无从下手，这时留言箱里一个名叫“夏娃”的ID吸引了他，说很仰慕他，想认识他，而且跟他在同一个城市。尧从来不和网友见面的，网上的那种互相看不见的神秘感官刺激是他期待的。然而他给夏娃留了他的电话。</p>\r\n<p>很快的，手机就响了，一个声音很妩媚的女孩，笑声甜的要出水。</p>\r\n<p>很投机，她是个很开朗的女孩，尧思维着。</p>\r\n<p>日子在匆匆着，采采依然陶醉于她的游戏，尧却渐渐象起了亚当。</p>\r\n<p>终于见面了，夏娃并不漂亮，颧骨有些高，眼睛还小，还浮着若干个小雀斑，唯一迷人的就是声音，一直在诱惑着尧的耳朵。</p>\r\n<p>夏娃说她和一个男的正不咸不淡着恋，如何的郁闷。尧也在谈着自己的苦恼。终于两个人在酒吧里喝得烂醉，尤其是夏娃，吐的一塌糊涂，老板一脸僵硬的笑着，半扶半抱地把他们带进了一辆计程车。上车后夏娃倒头就睡，尧胡乱指点，居然把车带到了自己家的门口。</p>\r\n<p>采采不在家，留有纸条，去她姐妹家玩游戏了，他好象清醒了一些，把夏娃放在床上，拉毯子盖着，自己去客厅的沙发上凑和。</p>\r\n<p>凌晨，正看着球赛，突然停电了，燥热，倒凉水喝。路过卧室时，却隐约听到里面有低低的呻吟声。</p>\r\n<p>他好奇的刚一推开门。居然恰巧来电了！</p>\r\n<p>只看到衣服在横七竖八的躺着，毯子在地上睡觉，夏娃真的成了伊甸园里的夏娃，一丝不挂。在呢喃着，扭动着，面如桃花。</p>\r\n<p>好象被什么击中了，他的头顿时嗡地一下昏了，只觉得更加躁热，汗滴流成了小溪，血液迅速冲击着全身，不知道是怎样来到床边的，拿着手指轻轻的抚摸着她的肌肤，感觉弹性的美妙！</p>\r\n<p>这时夏娃醒了，尧有些失措，他心虚的瞟了一下夏娃，却看到她眼中那跳动的深蓝色火苗。</p>\r\n<p>不晓得是谁扑上了谁。</p>\r\n<p>除了疯狂还是疯狂，无数次的缱绻缠绵，激情和新鲜，他好久没有过了。</p>\r\n<p>在疲倦中，他爆发了又一次激情，在愉快的晕旋中，他呐喊着：兽性比人性来的轻松啊！</p>\r\n<p>门在他们的嚎叫中飞开，采采顿时愣住了，笔记本电脑落地的响声大的可怕，两只手愣愣地站在那里，凉透。</p>\r\n<p>床上的人更是失措，呆了。几秒钟的时间后，尧明白过来，慌忙用毛毯把夏娃裹了起来，等待着暴风雨的来临！</p>\r\n<p>没有暴风雨，一切好象没有发生一样。</p>\r\n<p>采采没有打闹，脸被泪水爬满了，冰冷，血液凝固。而心底涌上来的一股极热的东西，迅速地灼烧着五脏六腑。</p>\r\n<p>她迅速收拾起一个行李箱，离开。</p>\r\n<p>尧只是在那里呆的好象弱智一样，不知所措。</p>\r\n<p>就这样，他们的爱情大厦在瞬间崩塌！</p>\r\n<p>打那以后，尧再也没有见到过采采，尽管他还在找着。而夏娃只是在那晚做了一次主角，尧还是想和采采厮守，那是他一直的追求。</p>\r\n<p>几年的爱情，他们之间早已对对方熟悉的致命，好象左手和右手。</p>\r\n<p>尧甚至可以想象出采采的想法：这样直接的看着他和别的女人在床上欢好的景象不能接受，那可是真正实实在在的激情狂欢。虽然她一直对自己的事情不管不问，其实是以一种近乎于狂妄的自信和游戏的态度，在不断考验着这段看上去坚固其实脆弱的爱情。</p>\r\n<p>犹如一杯水，现在这杯清澈的水浑了。泥沙总有沉底的一天，水也会恢复清澈，可是泥沙却将永留杯底，泼不掉了。</p>\r\n<p>爱情不需要聪明的考验，却需要聪明的经营。</p>\r\n<p>只是采采忘记了一件事：这世界上没有坚不可摧的男人。</p>\r\n<p>又有谁能经得起夏娃的诱惑呢？</p>", "Intro" : "尧轻轻地放下手中的碗，已经是连续8天的快食面了，现在闻到那种味道都有反胃的感觉。“你吃不吃面？”向隔壁的房间问，听到的只有游戏的燥乱的音乐声。于是尧把声音放的大些，终于有了回音，一个脆脆的女声：“来一筒！”", "Photo" : "", "Tags" : [], "Title" : "谁经得起夏娃的诱惑", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1056 }
{ "_id" : { "$oid" : "4a21e6103816398c1de14845" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>昨天一个逃犯从关押十五年的监狱逃跑了。</p>\r\n<p>他闯入了一对夫妇的家寻找食物和钱，却发现这对夫妇在床上。</p>\r\n<p>于是，他命令男人下床，并且把男人捆绑在椅子上。</p>\r\n<p>然后他又将老婆捆绑在床上，并长长地吻了她的脖子，然后走进了厕所。</p>\r\n<p>当逃犯在厕所的时候，丈夫对妻子说：“听着，这人一定是逃犯，只要看他的衣服就知道。他一定在监狱的时间太久，好多年都没有见过女人，从他亲吻你脖子的样子就看得出来。如果他要和你上床，千万不要抵抗，不要抱怨，按他说的去做，不管他如何蹂躏你，都要满足他的要求。他一定非常危险，如果他发怒的话，可能会将我们都杀了。你一定要挺住，宝贝，我爱你。”</p>\r\n<p>妻子对丈夫说：“他并没有亲吻我的脖子，而是在我耳边轻声说话。他告诉我他是同性恋，而且他觉得你很可爱，还问我家里有没有凡士林。我告诉他在厕所里。你一定要挺住，宝贝，我也爱你。”</p>", "Intro" : "昨天一个逃犯从关押十五年的监狱逃跑了。他闯入了一对夫妇的家寻找食物和钱，却发现这对夫妇在床上。于是，他命令男人下床，并且把男人捆绑在椅子上。", "Photo" : "", "Tags" : [], "Title" : "逃犯对一对夫妻做的变态事", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1050 }
{ "_id" : { "$oid" : "4a21e70c3816398c1de14843" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>(o)(o) ------------完美胸部</p>\r\n<p>(oYo) ------------ 美丽的胸部</p>\r\n<p>( + )( + )---------隆过的胸部</p>\r\n<p>(*)(*)------------ 高头头的胸部</p>\r\n<p>(@)(@)------------ 大头头的胸部</p>\r\n<p>{ O }{ O } ------- D罩杯的胸部</p>\r\n<p>( ^ )( ^ ) ------- 躺著时候的胸部</p>\r\n<p>(o)(O)------------不对称的胸部</p>\r\n<p>(Q)(O)----------- 有伤痕的胸部</p>\r\n<p>(p)(p)----------- 不穿内衣时的胸部</p>\r\n<p>o/o/ -----------祖母的胸部</p>\r\n<p>( - )( - )------- 平坦又靠著玻璃门的胸部</p>\r\n<p>(. Y .)----------波霸</p>\r\n<p>｜o｜ ｜o｜----------- 哥哥的胸部</p>", "Intro" : "各种胸部", "Photo" : "", "Tags" : [], "Title" : "各种大小型号“乳房”一览", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1075 }
{ "_id" : { "$oid" : "4a21e7a03816398c1de14841" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>话说抗日战争期间，日本鬼子来到了中国，一日本高级军官将自己的夫人也带来了。日本娘们要洗澡，于是就让一个汉奸给自己搓背。汉奸虽然满心不愿意，但是，摄于日本鬼子军官的淫威，不得不干，于是就与这个日本娘们共同进了浴池，整个浴池就他们二人。</p>\r\n<p>那个日本鬼子军官在其他屋，过了一会儿，他觉得不放心，就冲进浴池，一看，那个汉奸正在卖力地给日本娘们搓着背，日本娘们光着身子背对着汉奸，汉奸双手在她背上卖力地搓着；再往下看，那日本鬼子看见汉奸的那话儿直挺挺的翘着呢！于是鬼子大发雷霆，刷地抽出军刀，指着汉奸的那话儿：</p>\r\n<p>“巴嘎！你的，这个，什么地干活？！” </p>\r\n<p>汉奸脑子轰地一下，不过反应很快。他马上拿起一个毛巾，搭在那上面：</p>\r\n<p>“报告太君，毛巾的挂！”</p>\r\n<p>鬼子一看，觉得有理，于是就点点头，“尤西尤西”满意地走了。</p>\r\n<p>又过了一会儿，日本鬼子越琢磨越不是味儿，就又冲了进去，这次看到汉奸的那玩意儿已经从背后进到日本娘们的那里面了，还反反复复的；日本鬼子震怒了，就又抽出军刀：</p>\r\n<p>“巴嘎！这，又是什么地干活？”</p>\r\n<p>正在卖力干活的汉奸没有停下，边干边气喘吁吁地大声回答：</p>\r\n<p>“报告太君，外面的，搓完了；里面的，搓搓！”</p>", "Intro" : "话说抗日战争期间，日本鬼子来到了中国，一日本高级军官将自己的夫人也带来了。日本娘们要洗澡，于是就让一个汉奸给自己搓背。汉奸虽然满心不愿意，但是，摄于日本鬼子军官的淫威，不得不干，于是就与这个日本娘们共同进了浴池，整个浴池就他们二人。 ", "Photo" : "", "Tags" : [], "Title" : "日本女人搓澡", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1027 }
{ "_id" : { "$oid" : "4a21e8023816398c1de1483f" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>两个人在一起真的是很需要缘份，既然你们选择了在一起，就用点智慧好好的经营你们的爱情吧。</p>\r\n<p>第一：不要问女人以前的事，毕竟过去的事了，说的详细你又受不了，说的简单你就心里老是打问號。</p>\r\n<p>第二：同样，你也不要和她说太多以前的事，特别是你以前如何如何的深情，如何如何的不要自尊去爱另一个女人。</p>\r\n<p>第三：不要有处女情结，虽然现在这社会，有处女情结的人不会很多，但终究是男人，多多少少会介意，记得摆正自己的心态。</p>\r\n<p>第四：不要太大男人主义，现在的新时代女性，再也不是以前的那些唯命是从的小女子了，过于大男人主义，会让人受不了。</p>\r\n<p>第五：ML时不要过于形式化，形式化让人觉得你没情调，也不要样样都懂，这样会吓坏你的小MM，让她怀疑你以前有N段风流史。</p>\r\n<p>第六：不要当面去夸别人的女人漂亮，女人嘛，永远都觉得自己是最美的，你可以夸别的女人另一些，比如她的内在美，这样令她觉得自己的不足之余，又懂得努力去改正自己。</p>\r\n<p>第七：不要拿你以前的女友与她相比，说以前那个如何如何的好，那是不公平的，不同的人如何去比较呢？</p>\r\n<p>第八：不要在朋友面前，不拉她的手，或不抱抱她，那样她会很伤心，觉得你并不在乎她，也令她没面子，适当的在别人面前表现恩爱是必要的，（特别不能在朋友面前对她呼呼喝喝）。</p>\r\n<p>第十一：不要不懂得说情话，甜言密语是爱情的润滑剂，但过多，就显得虚假。</p>\r\n<p>第十二：不要轻易去怀疑另一半，过度的不信任让人觉得你没自信之余，又心胸狭窄。</p>\r\n<p>第十三：不要试图去绑住一个女人，要坚信你温暖的怀抱是她一生的依靠，过多的举动则会吓跑对方。</p>\r\n<p>第十四：不要不懂得体贴另一半，累了发个短信打个电话安慰一下，那比买任何礼物来得贴心。</p>\r\n<p>第十五：不要对不懂的事装懂，现在的女人可不是草包，很容易一眼就看穿你的肤浅，不懂就说出来，有什么大不了。</p>\r\n<p>第十六：不要在气跑女朋友之后也不追，甚至一个短信也不发，那样很容易让女人心灰意冷。</p>\r\n<p>第十七：不要在谈恋爱的时候，就把以后的事说的太现实化，那样会吓得她不敢和你走进婚姻的礼堂（结婚需要冲动，经营婚姻需要智慧，离婚需要勇气）</p>\r\n<p>第十八：不要在开始的谈恋爱的时候，就急着说性，那样会让人觉得你只用下半身和她谈恋爱。</p>\r\n<p>第十九：不要把工作情绪带给她，你可以向她倾诉，但不要因为工作的问题向她发脾气。</p>\r\n<p>第二十：不要睡在她身边的时候喊的是别人的名字，切记切记切记。</p>", "Intro" : "两个人在一起真的是很需要缘份，既然你们选择了在一起，就用点智慧好好的经营你们的爱情吧。　", "Photo" : "", "Tags" : [], "Title" : "两个人在一起真的是很需要缘份吗？", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1434 }
{ "_id" : { "$oid" : "4a21e85f3816398c1de1483d" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>大部分的男人无法理解女人经前经後的歇斯底里，甚至有的男人坚持，如果女人天天要求两性平权，就不应该利用月经扮演弱者博取同情。</p>\r\n<p>如果男人在自己的下体被高跟鞋连踹七天而不哀不缩，那女人也可以平静地度过经期。</p>\r\n<p>有那么痛吗？因人而异。</p>\r\n<p>有的女性甚至可以因为经痛痛到晕过去，你觉得呢？</p>\r\n<p>月经来潮时的下腹肿胀、绞痛，摄氏32℃的气温下却可以四肢冰冷，甚至寸步难行举步维艰，你就知道有多痛了。</p>\r\n<p>生理上的痛我不想著墨太多，因为男人真的很难体会。</p>\r\n<p>就光谈月经来潮为何使人焦虑不安、情绪难平吧！</p>\r\n<p>男人们，请你试著铺一束湿卫生纸在你裤裆间连续５～７天而且，请注意，每隔１～３小时不等（视流量而定）更换一次，免得溢出哦！</p>\r\n<p>就算一个成年女人已经和月经相处了十几年，她还是无法算准何时能准地接下第一滴血。</p>\r\n<p>有时候，周期到了，理所当然地先垫一块防患於未然，谁知道垫了４、５天却是一场空，就在你准备放弃抽出卫生棉时，冷不防地天降甘霖，你只好祈祷自己不在野外或刚好不是白裤子。</p>\r\n<p>跨间夹著一条湿湿的棉纸有多难受？</p>\r\n<p>更难受的是，有时候很难光凭感觉得知它是否容量已满，如果你是一个忙碌的上班族，有很多会要开；或你刚好是卖甜不辣的妈妈，公厕要走很远；或你刚好是个要发片的女艺人，今天MTV要穿超短裤或下水演悲情；你能不焦虑吗？</p>\r\n<p>有时候以为已满溢，冲到厕所一看，才占了１/３，要不要换新的？</p>\r\n<p>有时候坐著喝咖啡，两腿夹的紧紧的；嘴里的温热转移了下体的温度感受，待回过神来，走进厕所检查，却发现月经已波涛汹涌地满溢，自然又是一阵手忙脚乱；你能不情绪化吗？</p>\r\n<p>相信男孩子大多有梦遗的经验吧！洗床单烦不烦？</p>\r\n<p>请想一下，你们洗的是透明的，我们洗的却是血染，难不难？</p>\r\n<p>月经不比自来水，开关由自己操作，要停要来随心所欲；我想，男人大概不明了，经血那种欲走还留的任性有多令人抓狂吧？</p>\r\n<p>最後１、２天，经血明显变少；有时候，一整天只有一滴，自己觉得应该不再需要卫生棉时，冷不防地它又在半夜吐了一口，不多不少，像是文弱书生得肺痨临死前吐的那一口。</p>\r\n<p>一口，就又得洗内裤、床单，和床单下的被垫了。</p>\r\n<p>所以，男人们，你能开始了解女人、体谅女人的经前症候群吗？</p>\r\n<p>别看见血就嫌脏，别忘了，你们一个个都是从那儿孕育出来的呢，下次，帮忙洗个床单吧！</p>", "Intro" : "大部分的男人无法理解女人经前经後的歇斯底里， 甚至有的男人坚持，如果女人天天要求两性平权， 就不应该利用月经扮演弱者博取同情。 如果男人在自己的下体被高跟鞋连踹七天而不哀不缩， 那女人也可以平静地度过经期。有那么痛吗？因人而异。 有的女性甚至可以因为经痛痛到晕过去，你觉得呢？ ", "Photo" : "", "Tags" : [], "Title" : "陶晶莹的月经论述（女生要看，男生更要看）", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 1618 }
{ "_id" : { "$oid" : "4a21e95d3816398c1de1483b" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p><b>喝酒的规矩：</b></p>\r\n<ol>\r\n<li>酒桌上虽然“感情深，一口闷；感情浅，舔一舔”但是喝酒的时候决不能把这句话挂在嘴上。</li>\r\n<li>韬光养晦，厚集播发，切不可一上酒桌就充大。</li>\r\n<li>领导相互喝完才轮到自己敬。</li>\r\n<li>可以多人敬一人，决不可一人敬多人，除非你是领导。</li>\r\n<li>自己敬别人，如果不碰杯，自己喝多少可视乎情况而定，比如对方酒量，对方喝酒态度，切不可比对方喝得少，要知道是自己敬人。</li>\r\n<li>自己敬别人，如果碰杯，一句，我喝完，你随意，方显大肚。</li>\r\n<li>自己职位卑微，记得多给领导添酒，不要瞎给领导代酒，就是要代，也要在领导确实想找人代，还要装作自己是因为想喝酒而不是为了给领导代酒而喝酒。比如领导甲不胜酒力，可以通过旁敲侧击把准备敬领导甲的人拦下。</li>\r\n<li>端起酒杯（啤酒杯），右手扼杯，左手垫杯底，记着自己的杯子永远低于别人。自己如果是领导，知趣点，不要放太低，不然怎么叫下面的做人？</li>\r\n<li>如果没有特殊人物在场，碰酒最好按时针顺序，不要厚此薄彼。</li>\r\n<li>碰杯，敬酒，要有说词，不然，我tmd干吗要喝你的酒？</li>\r\n<li>桌面上不谈生意，喝好了，生意也就差不多了，大家心里面了了然，不然人家也不会敞开了跟你喝酒。</li>\r\n<li>不要装歪，说错话，办错事，不要申辩，自觉罚酒才是硬道理。</li>\r\n<li>假如，纯粹是假如，遇到酒不够的情况，酒瓶放在桌子中间，让人自己添，不要傻不垃圾的去一个一个倒酒，不然后面的人没酒怎么办？</li>\r\n<li>最后一定还有一个闷杯酒，所以，不要让自己的酒杯空着。跑不了的~</li>\r\n<li> 注意酒后不要失言，不要说大话，不要失态，不要吐沫横飞，筷子乱甩，不要手指乱指，喝汤噗噗响，不要放屁打嗝，憋不住去厕所去，没人拦你。</li>\r\n<li>不要把“我不会喝酒”挂在嘴上（如果你喝的话），免得别人骂你虚伪，不管你信不信，人能不能喝酒还真能看出来。</li>\r\n<li>领导跟你喝酒，是给你face，不管领导怎么要你喝多少，自己先干为敬，记着啊，双手，杯子要低。</li>\r\n<li>花生米对喝酒人来说，是个好东西。保持清醒的头脑，酒后嘘寒问暖是少不了的，一杯酸奶，一杯热水，一条热毛巾都显得你关怀备至。</li>\r\n</ol>\r\n<p><b>如果你酒量不怎么样，给你一些诀窍：</b></p>\r\n<ol>\r\n<li>不要主动出击，实行以守为攻战略</li>\r\n<li>桌前放两个大杯，一杯放白酒，一杯放矿泉水，拿小酒盅干杯，勤喝水，到酒桌上主客基本都喝8分醉时，可以以水代酒，主动出击（这条不建议用）</li>\r\n<li>干杯后，不要马上咽下去，找机会用餐巾抹嘴，把酒吐餐巾里（适用女性）</li>\r\n<li>上座后先吃一些肥肉类、淀粉类食品垫底，喝酒不容易醉</li>\r\n<li>掌握节奏，不要一下子喝得太猛</li>\r\n<li>不要几种酒混着喝，特别容易醉</li>\r\n<li>领导夹菜时，千万不要转酒桌中间的圆盘，领导夹菜你转盘是酒桌上大忌</li>\r\n<li>喝到六分醉时，把你面前的醋碟中的醋喝下，再让服务员添上……</li>\r\n<li>每次干杯时，倒满，然后在喝前假装没有拿稳酒盅，尽量洒出去一些，这样每次可以少喝进去不少</li>\r\n</ol>", "Intro" : "规矩一 酒桌上虽然“感情深，一口闷；感情浅，舔一舔”但是喝酒的时候决不能把这句话挂在嘴上。\r\n规矩二 韬光养晦，厚集播发，切不可一上酒桌就充大。\r\n规矩三 领导相互喝完才轮到自己敬。\r\n...", "Photo" : "", "Tags" : [], "Title" : "喝酒的技巧（非常实用）", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2116 }
{ "_id" : { "$oid" : "4a21eafa3816398c1de14839" }, "Bookmark" : 0, "Cate" : "ASP.NET", "Content" : "<p>动态联接库(DLL)可以加快应用程序关键部分的执行速度，同时通过统一的COM接口调用，对DLL的使用也可以最大限度地发挥组件的重用性。用户不必关心DLL采用什么语言编写，只需关注其提供了哪些功能及接口参数，便可以为我所用。</p>\r\n<p>目前，基于.Net技术编写的DLL组件越来越多，而传统的ASP中如果也可以应用这些组件提供的功能，可以避免很多程序员无谓的劳动。</p>\r\n<h6><b>1. 在ASP中调用传统的ActiveX DLL</b></h6>\r\n<p>要想让COM能够“看到”你的组件，必须先将组件注册到注册表中：</p>\r\n<div class=\"highlight\"><pre><code class=\"js\"><span class=\"k\">regsvr32</span> mydll.dll</code></pre></div>\r\n<p>然后在ASP中创建对象：</p>\r\n<div class=\"highlight\"><pre><code class=\"js\"><span class=\"k\">set</span> mydll = server.createobject(<span class=\"s1\">\"mydll.method\"</span>);\r\nmydll.method;</code></pre></div>\r\n<p>这样就可以使用组件中的属性和方法了。</p>\r\n<h6><b>2. 在ASP中调用基于.Net开发的DLL</b></h6>\r\n<p>关于组件注册，一种方法是自动注册，在vs.net2003或2005的IDE环境中可以实现COM组件的自动注册，设置如下：项目名称->右键\"属性\"->配置属性->生成->选中\"为Com Interop注册\"，编译即可。</p>\r\n<p>另一种方法是手动注册：</p>\r\n<div class=\"highlight\"><pre><code class=\"js\"><span class=\"k\">regasm</span> mydll.dll /tlb:mydll.tlb /CodeBase</code></pre></div>\r\n<p>注意CodeBase的使用，如果你要注册的.NET程序集没有强名称的话，那么在使用regasm注册的时候就要加上/CodeBase。</p>\r\n<p>注册完毕，创建对象及使用方法与上面相同：</p>\r\n<div class=\"highlight\"><pre><code class=\"js\"><span class=\"k\">set</span> mydll = server.createobject(<span class=\"s1\">\"mydll.method\"</span>);\r\nmydll.method;</code></pre></div>\r\n<p>其实，不只是ASP，其他的COM程序（包括VBA、扩展存储过程等等）调用DLL的方法都是一样的。</p>\r\n<p>有关于regasm的参数，请参考：</p>\r\n<p><a href=\"http://msdn.microsoft.com/library/chs/default.asp?url=/library/CHS/cptools/html/cpgrfassemblyregistrationtoolregasmexe.asp\">http://msdn.microsoft.com/library/chs/default.asp?url=/library/CHS/cptools/html/cpgrfassemblyregistrationtoolregasmexe.asp</a></p>", "Intro" : "动态联接库(DLL)可以加快应用程序关键部分的执行速度，同时通过统一的COM接口调用，对DLL的使用也可以最大限度地发挥组件的重用性。用户不必关心DLL采用什么语言编写，只需关注其提供了哪些功能及接口参数，便可以为我所用。目前，基于.Net技术编写的DLL组件越来越多，而传统的ASP中如果也可以应用这些组件提供的功能，可以避免很多程序员无谓的劳动。", "Photo" : "", "Tags" : [ "ASP", "DLL" ], "Title" : "在ASP中调用DLL的方法", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2183 }
{ "_id" : { "$oid" : "4a21ebaa3816398c1de14837" }, "Bookmark" : 0, "Cate" : "ASP.NET", "Content" : "<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>&amp;lt;%<br />\r\nResponse.CharSet = &amp;quot;utf-8&amp;quot;</p>\r\n<p>Set xmlhttp = Server.Cr&#101;ateObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;)</p>\r\n<p>xmlhttp.Open &amp;quot;GET&amp;quot;,&amp;quot;<a href=&#34;http://localhost/ext2.2/my/form1.asp&amp;quot;,False&#34;>http://localhost/ext2.2/my/form1.asp&amp;quot;,False</a>&amp;nbsp;&amp;nbsp; &#39;动态生成的xml<br />\r\nxmlhttp.Send</p>\r\n<p>Set xml = Server.Cr&#101;ateObject(&amp;quot;Msxml2.DOMDocument&amp;quot;)<br />\r\nxml.async = false<br />\r\n&#39;xml.load(Server.Mappath(&amp;quot;2.xml&amp;quot;)) &amp;rsquo;可以使用本地的xml，如果想使用远程的xml必须用上面的xmlhttp方式获取<br />\r\nxml.loadxml(xmlhttp.responseText)</p>\r\n<p>Set xsl = Server.Cr&#101;ateObject(&amp;quot;Msxml.DOMDocument&amp;quot;)<br />\r\nxsl.async = false<br />\r\nxsl.load(Server.Mappath(&amp;quot;1.xsl&amp;quot;))</p>\r\n<p>Response.Write xml.transformNode(xsl)</p>\r\n<p>Set xmlhttp = Nothing <br />\r\nSet xml = Nothing <br />\r\nSet xsl = Nothing<br />\r\n%&amp;gt;</p>\r\n</div>\r\n<p>最近在搞extjs，使用的版本是2.2，服务器端采用asp，方便省事。asp好久没摸了，以前关于这块的内容不知道放哪去了，反正是在电脑里，巴拉老半天也找不到，所以还是重新搞一搞吧，搞了老半天才搞出个模样，还是记录一下吧，免得又忘了。下面是js方式。</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>&amp;lt;SCRIPT LANGUAGE=&amp;quot;JavaScript&amp;quot;&amp;gt;<br />\r\n&amp;lt;!--<br />\r\nvar xml = new ActiveXObject(&amp;quot;MSXML.DOMDocument&amp;quot;);<br />\r\nxml.async = false;<br />\r\nxml.load(&amp;quot;<a href=&#34;http://localhost/ext2.2/my/form1.asp&#34;>http://localhost/ext2.2/my/form1.asp</a>&amp;quot;);</p>\r\n<p>var xsl = new ActiveXObject(&amp;quot;MSXML.DOMDocument&amp;quot;);<br />\r\nxsl.async = false;<br />\r\nxsl.load(&amp;quot;<a href=&#34;http://localhost/ext2.2/my/1.xsl&#34;>http://localhost/ext2.2/my/1.xsl</a>&amp;quot;);<br />\r\nalert(xml.transformNode(xsl));<br />\r\n//--&amp;gt;<br />\r\n&amp;lt;/SCRIPT&amp;gt;</p>\r\n</div>", "Intro" : "<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>\r\n<p>&amp;lt;%<br />\r\nResponse.CharSet = &amp;quot;utf-8&amp;quot;</p>\r\n<p>Set xmlhttp = Server.Cr&#101;ateObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;)</p>\r\n<p>xmlhttp.Open &amp;quot;GET&amp;quot;,&amp;quot;<a href=&#34;http://localhost/ext2.2/my/form1.asp&amp;quot;,False&#34;>http://localhost/ext2.2/my/form1.asp&amp;quot;,False</a>&amp;nbsp;&amp;nbsp; &#39;动态生成的xml<br />\r\nxmlhttp.Send</p>\r\n<p>Set xml = Server.Cr&#101;ateObject(&amp;quot;Msxml2.DOMDocument&amp;quot;)<br />\r\nxml.async = false<br />\r\n&#39;xml.load(Server.Mappath(&amp;quot;2.xml&amp;quot;)) &amp;rsquo;可以使用本地的xml，如果想使用远程的xml必须用上面的xmlhttp方式获取<br />\r\nxml.loadxml(xmlhttp.responseText)</p>\r\n</div>", "Photo" : "", "Tags" : [ "ASP", "XMLHTTP" ], "Title" : "ASP中使用XMLHTTP方式获取XML并与XSL结合解析生成字符串方式", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2606 }
{ "_id" : { "$oid" : "4a222c673816398c1de14835" }, "Bookmark" : 0, "Cate" : "Java", "Content" : "<p>&amp;nbsp;在项目中，我们很多都用到了xml文件，无论是参数配置还是与其它系统的数据交互。<br />\r\n今天就来讲一下Java 中使用dom4j来操作XML文件。</p>\r\n<p>我们需要引入的包：</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>//文件包 <br />\r\nimport java.io.ByteArrayOutputStream; <br />\r\nimport java.io.File; <br />\r\nimport java.io.FileWriter; <br />\r\n//工具包 <br />\r\nimport java.util.Iterator; <br />\r\nimport java.util.List; <br />\r\n//dom4j包 <br />\r\nimport o&#114;g.dom4j.Attribute; <br />\r\nimport o&#114;g.dom4j.Document; <br />\r\nimport o&#114;g.dom4j.DocumentHelper; <br />\r\nimport o&#114;g.dom4j.Element; <br />\r\nimport o&#114;g.dom4j.io.OutputFormat; <br />\r\nimport o&#114;g.dom4j.io.SAXReader; <br />\r\nimport o&#114;g.dom4j.io.XMLWriter;</div>\r\n<p>1. 将XML文件的内容转化为String</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* doc2String <br />\r\n&amp;nbsp;* 将xml文档内容转为String <br />\r\n&amp;nbsp;* @return 字符串 <br />\r\n&amp;nbsp;* @param document <br />\r\n&amp;nbsp;*/ <br />\r\npublic static String doc2String(Document document){ <br />\r\n&amp;nbsp;String s = &amp;quot;&amp;quot;; <br />\r\n&amp;nbsp;try{ <br />\r\n&amp;nbsp;&amp;nbsp;//使用输出流来进行转化 <br />\r\n&amp;nbsp;&amp;nbsp;ByteArrayOutputStream out = new ByteArrayOutputStream(); <br />\r\n&amp;nbsp;&amp;nbsp;//使用GB2312编码 <br />\r\n&amp;nbsp;&amp;nbsp;OutputFormat format = new OutputFormat(&amp;quot;&amp;nbsp; &amp;quot;, true, &amp;quot;GB2312&amp;quot;); <br />\r\n&amp;nbsp;&amp;nbsp;XMLWriter writer = new XMLWriter(out, format); <br />\r\n&amp;nbsp;&amp;nbsp;writer.write(document); <br />\r\n&amp;nbsp;&amp;nbsp;s = out.toString(&amp;quot;GB2312&amp;quot;); <br />\r\n&amp;nbsp;}<br />\r\n&amp;nbsp;catch(Exception ex){&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;&amp;nbsp;ex.printStackTrace(); <br />\r\n&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;return s; <br />\r\n}</div>\r\n<p>2. 将符合XML格式的String 转化为XML Document</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* string2Document <br />\r\n&amp;nbsp;* 将字符串转为Document <br />\r\n&amp;nbsp;* @return&amp;nbsp; <br />\r\n&amp;nbsp;* @param s xml格式的字符串 <br />\r\n&amp;nbsp;*/ <br />\r\npublic static Document string2Document(String s){ <br />\r\n&amp;nbsp;Document doc = null; <br />\r\n&amp;nbsp;try{ <br />\r\n&amp;nbsp;&amp;nbsp;doc = DocumentHelper.parseText(s); <br />\r\n&amp;nbsp;}<br />\r\n&amp;nbsp;catch(Exception ex){&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;&amp;nbsp;ex.printStackTrace(); <br />\r\n&amp;nbsp;} <br />\r\n&amp;nbsp;return doc; <br />\r\n}</div>\r\n<p>3. 将Document对象保存为一个xml文件到本地</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* doc2XmlFile <br />\r\n&amp;nbsp;* 将Document对象保存为一个xml文件到本地 <br />\r\n&amp;nbsp;* @return true:保存成功&amp;nbsp; flase:失败 <br />\r\n&amp;nbsp;* @param filename 保存的文件名 <br />\r\n&amp;nbsp;* @param document 需要保存的document对象 <br />\r\n&amp;nbsp;*/ <br />\r\npublic static boolean doc2XmlFile(Document document,String filename){ <br />\r\n&amp;nbsp;boolean flag = true; <br />\r\n&amp;nbsp;try{ <br />\r\n&amp;nbsp;&amp;nbsp;/* 将document中的内容写入文件中 */ <br />\r\n&amp;nbsp;&amp;nbsp;//默认为UTF-8格式，指定为&amp;quot;GB2312&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;OutputFormat format = OutputFormat.cr&#101;atePrettyPrint(); <br />\r\n&amp;nbsp;&amp;nbsp;format.setEncoding(&amp;quot;GB2312&amp;quot;); <br />\r\n&amp;nbsp;&amp;nbsp;XMLWriter writer = new XMLWriter(new FileWriter(new File(filename)),format); <br />\r\n&amp;nbsp;&amp;nbsp;writer.write(document); <br />\r\n&amp;nbsp;&amp;nbsp;writer.close();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;}<br />\r\n&amp;nbsp;catch(Exception ex){ <br />\r\n&amp;nbsp;&amp;nbsp;flag = false; <br />\r\n&amp;nbsp;&amp;nbsp;ex.printStackTrace(); <br />\r\n&amp;nbsp;} <br />\r\n&amp;nbsp;return flag;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n}</div>\r\n<p>4. 将xml格式的字符串保存为本地文件，如果字符串格式不符合xml规则，则返回失败</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* string2XmlFile <br />\r\n&amp;nbsp;* 将xml格式的字符串保存为本地文件，如果字符串格式不符合xml规则，则返回失败 <br />\r\n&amp;nbsp;* @return true:保存成功&amp;nbsp; flase:失败 <br />\r\n&amp;nbsp;* @param filename 保存的文件名 <br />\r\n&amp;nbsp;* @param str 需要保存的字符串 <br />\r\n&amp;nbsp;*/ <br />\r\npublic static boolean string2XmlFile(String str,String filename){ <br />\r\n&amp;nbsp;boolean flag = true; <br />\r\n&amp;nbsp;try{ <br />\r\n&amp;nbsp;&amp;nbsp;Document doc =&amp;nbsp; DocumentHelper.parseText(str);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;&amp;nbsp;flag = doc2XmlFile(doc,filename); <br />\r\n&amp;nbsp;}<br />\r\n&amp;nbsp;catch (Exception ex){ <br />\r\n&amp;nbsp;&amp;nbsp;flag = false; <br />\r\n&amp;nbsp;&amp;nbsp;ex.printStackTrace(); <br />\r\n&amp;nbsp;} <br />\r\n&amp;nbsp;return flag; <br />\r\n}</div>\r\n<p>5. 载入一个xml文档</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* load <br />\r\n&amp;nbsp;* 载入一个xml文档 <br />\r\n&amp;nbsp;* @return 成功返回Document对象，失败返回null <br />\r\n&amp;nbsp;* @param uri 文件路径 <br />\r\n&amp;nbsp;*/ <br />\r\npublic static Document load(String filename){ <br />\r\n&amp;nbsp;Document document = null; <br />\r\n&amp;nbsp;try{&amp;nbsp; <br />\r\n&amp;nbsp;&amp;nbsp;SAXReader saxReader = new SAXReader(); <br />\r\n&amp;nbsp;&amp;nbsp;document = saxReader.read(new File(filename)); <br />\r\n&amp;nbsp;} <br />\r\n&amp;nbsp;catch (Exception ex){ <br />\r\n&amp;nbsp;&amp;nbsp;ex.printStackTrace(); <br />\r\n&amp;nbsp;}&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;return document; <br />\r\n}</div>\r\n<p>6. 演示String保存为xml文件</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* xmlWriteDemoByString <br />\r\n&amp;nbsp;* 演示String保存为xml文件 <br />\r\n&amp;nbsp;*/ <br />\r\npublic void xmlWriteDemoByString(){ <br />\r\n&amp;nbsp;String s = &amp;quot;&amp;quot;; <br />\r\n&amp;nbsp;/** xml格式标题 &amp;quot;&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;GB2312&#39;?&amp;gt;&amp;quot; 可以不用写*/ <br />\r\n&amp;nbsp;s = &amp;quot;&amp;lt;config&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp; &amp;lt;ftp name=&#39;DongDian&#39;&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;ftp-host&amp;gt;127.0.0.1&amp;lt;/ftp-host&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;ftp-port&amp;gt;21&amp;lt;/ftp-port&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;ftp-user&amp;gt;cxl&amp;lt;/ftp-user&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;ftp-pwd&amp;gt;longshine&amp;lt;/ftp-pwd&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;!-- ftp最多尝试连接次数 --&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;ftp-try&amp;gt;50&amp;lt;/ftp-try&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;!-- ftp尝试连接延迟时间 --&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;ftp-delay&amp;gt;10&amp;lt;/ftp-delay&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;nbsp; &amp;lt;/ftp&amp;gt;\\r\\n&amp;quot; <br />\r\n&amp;nbsp;&amp;nbsp;+&amp;quot;&amp;lt;/config&amp;gt;\\r\\n&amp;quot;; <br />\r\n&amp;nbsp;//将文件生成到classes文件夹所在的目录里&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;string2XmlFile(s,&amp;quot;xmlWriteDemoByString.xml&amp;quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;//将文件生成到classes文件夹里&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;string2XmlFile(s,&amp;quot;classes/xmlWriteDemoByString.xml&amp;quot;);&amp;nbsp;&amp;nbsp; <br />\r\n}</div>\r\n<p>7. 演示手动创建一个Document，并保存为XML文件</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* 演示手动创建一个Document，并保存为XML文件 <br />\r\n&amp;nbsp;*/ <br />\r\npublic void xmlWriteDemoByDocument(){ <br />\r\n&amp;nbsp;/** 建立document对象 */ <br />\r\n&amp;nbsp;Document document = DocumentHelper.cr&#101;ateDocument(); <br />\r\n&amp;nbsp;/** 建立config根节点 */ <br />\r\n&amp;nbsp;Element configElement = document.addElement(&amp;quot;config&amp;quot;); <br />\r\n&amp;nbsp;/** 建立ftp节点 */ <br />\r\n&amp;nbsp;configElement.addComment(&amp;quot;东电ftp配置&amp;quot;); <br />\r\n&amp;nbsp;Element ftpElement = configElement.addElement(&amp;quot;ftp&amp;quot;); <br />\r\n&amp;nbsp;ftpElement.addAttribute(&amp;quot;name&amp;quot;,&amp;quot;DongDian&amp;quot;); <br />\r\n&amp;nbsp;/** ftp 属性配置 */ <br />\r\n&amp;nbsp;Element hostElement = ftpElement.addElement(&amp;quot;ftp-host&amp;quot;); <br />\r\n&amp;nbsp;hostElement.setText(&amp;quot;127.0.0.1&amp;quot;); <br />\r\n&amp;nbsp;(ftpElement.addElement(&amp;quot;ftp-port&amp;quot;)).setText(&amp;quot;21&amp;quot;); <br />\r\n&amp;nbsp;(ftpElement.addElement(&amp;quot;ftp-user&amp;quot;)).setText(&amp;quot;cxl&amp;quot;); <br />\r\n&amp;nbsp;(ftpElement.addElement(&amp;quot;ftp-pwd&amp;quot;)).setText(&amp;quot;longshine&amp;quot;); <br />\r\n&amp;nbsp;ftpElement.addComment(&amp;quot;ftp最多尝试连接次数&amp;quot;); <br />\r\n&amp;nbsp;(ftpElement.addElement(&amp;quot;ftp-try&amp;quot;)).setText(&amp;quot;50&amp;quot;); <br />\r\n&amp;nbsp;ftpElement.addComment(&amp;quot;ftp尝试连接延迟时间&amp;quot;); <br />\r\n&amp;nbsp;(ftpElement.addElement(&amp;quot;ftp-delay&amp;quot;)).setText(&amp;quot;10&amp;quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;/** 保存Document */ <br />\r\n&amp;nbsp;doc2XmlFile(document,&amp;quot;classes/xmlWriteDemoByDocument.xml&amp;quot;); <br />\r\n}</div>\r\n<p>8. 演示读取文件的具体某个节点的值</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;*&amp;nbsp; 演示读取文件的具体某个节点的值&amp;nbsp; <br />\r\n&amp;nbsp;*/ <br />\r\npublic static void xmlReadDemo(){ <br />\r\n&amp;nbsp;Document doc = load(&amp;quot;classes/xmlWriteDemoByDocument.xml&amp;quot;); <br />\r\n&amp;nbsp;//Element root = doc.getRootElement(); <br />\r\n&amp;nbsp;/** 先用xpath查找所有ftp节点 并输出它的name属性值*/ <br />\r\n&amp;nbsp;List list = doc.sel&#101;ctNodes(&amp;quot;/config/ftp&amp;quot; ); <br />\r\n&amp;nbsp;Iterator it = list.iterator(); <br />\r\n&amp;nbsp;while(it.hasNext()){&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;&amp;nbsp;Element ftpElement = (Element)it.next(); <br />\r\n&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;ftp_name=&amp;quot;+ftpElement.attribute(&amp;quot;name&amp;quot;).getValue()); <br />\r\n&amp;nbsp;} <br />\r\n&amp;nbsp;/** 直接用属性path取得name值 */ <br />\r\n&amp;nbsp;list = doc.sel&#101;ctNodes(&amp;quot;<a>/config/ftp/@name</a>&amp;quot; ); <br />\r\n&amp;nbsp;it = list.iterator(); <br />\r\n&amp;nbsp;while(it.hasNext()){&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;&amp;nbsp;Attribute attribute = (Attribute)it.next(); <br />\r\n&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;@name=&amp;quot;+attribute.getValue()); <br />\r\n&amp;nbsp;} <br />\r\n&amp;nbsp;/** 直接取得DongDian ftp的 ftp-host 的值 */ <br />\r\n&amp;nbsp;list = doc.sel&#101;ctNodes(&amp;quot;/config/ftp/ftp-host&amp;quot; ); <br />\r\n&amp;nbsp;it = list.iterator(); <br />\r\n&amp;nbsp;Element hostElement=(Element)it.next(); <br />\r\n&amp;nbsp;System.out.println(&amp;quot;DongDian&#39;s ftp_host=&amp;quot;+hostElement.getText()); <br />\r\n}</div>\r\n<p>9. 修改或删除某个值或属性</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** ftp节点删除ftp-host节点 */ <br />\r\nftpElement.remove(hostElement);&amp;nbsp; <br />\r\n/** ftp节点删除name属性 */ <br />\r\nftpElement.remove(nameAttribute); <br />\r\n/** 修改ftp-host的值 */ <br />\r\nhostElement.setText(&amp;quot;192.168.0.1&amp;quot;);&amp;nbsp; <br />\r\n/** 修改ftp节点name属性的值 */ <br />\r\nnameAttribute.setValue(&amp;quot;ChiFeng&amp;quot;);</div>", "Intro" : "<p>&amp;nbsp;在项目中，我们很多都用到了xml文件，无论是参数配置还是与其它系统的数据交互。<br />\r\n今天就来讲一下Java 中使用dom4j来操作XML文件。</p>\r\n<p>我们需要引入的包：</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>//文件包 <br />\r\nimport java.io.ByteArrayOutputStream; <br />\r\nimport java.io.File; <br />\r\nimport java.io.FileWriter; <br />\r\n//工具包 <br />\r\nimport java.util.Iterator; <br />\r\nimport java.util.List; <br />\r\n//dom4j包 <br />\r\nimport o&#114;g.dom4j.Attribute; <br />\r\nimport o&#114;g.dom4j.Document; <br />\r\nimport o&#114;g.dom4j.DocumentHelper; <br />\r\nimport o&#114;g.dom4j.Element; <br />\r\nimport o&#114;g.dom4j.io.OutputFormat; <br />\r\nimport o&#114;g.dom4j.io.SAXReader; <br />\r\nimport o&#114;g.dom4j.io.XMLWriter;</div>\r\n<p>1. 将XML文件的内容转化为String</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* doc2String <br />\r\n&amp;nbsp;* 将xml文档内容转为String <br />\r\n&amp;nbsp;* @return 字符串 <br />\r\n&amp;nbsp;* @param document <br />\r\n&amp;nbsp;*/ <br />\r\npublic static String doc2String(Document document){ <br />\r\n&amp;nbsp;String s = &amp;quot;&amp;quot;; <br />\r\n&amp;nbsp;try{ <br />\r\n&amp;nbsp;&amp;nbsp;//使用输出流来进行转化 <br />\r\n&amp;nbsp;&amp;nbsp;ByteArrayOutputStream out = new ByteArrayOutputStream(); <br />\r\n&amp;nbsp;&amp;nbsp;//使用GB2312编码 <br />\r\n&amp;nbsp;&amp;nbsp;OutputFormat format = new OutputFormat(&amp;quot;&amp;nbsp; &amp;quot;, true, &amp;quot;GB2312&amp;quot;); <br />\r\n&amp;nbsp;&amp;nbsp;XMLWriter writer = new XMLWriter(out, format); <br />\r\n&amp;nbsp;&amp;nbsp;writer.write(document); <br />\r\n&amp;nbsp;&amp;nbsp;s = out.toString(&amp;quot;GB2312&amp;quot;); <br />\r\n&amp;nbsp;}<br />\r\n&amp;nbsp;catch(Exception ex){&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;&amp;nbsp;ex.printStackTrace(); <br />\r\n&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;return s; <br />\r\n}</div>\r\n<p>2. 将符合XML格式的String 转化为XML Document</p>\r\n<div style=&#34;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; background: #e6e6e6; padding-bottom: 4px; border-left: windowtext 0.5pt solid; width: 95%; word-break: break-all; padding-top: 4px; border-bottom: windowtext 0.5pt solid&#34;>/** <br />\r\n&amp;nbsp;* string2Document <br />\r\n&amp;nbsp;* 将字符串转为Document <br />\r\n&amp;nbsp;* @return&amp;nbsp; <br />\r\n&amp;nbsp;* @param s xml格式的字符串 <br />\r\n&amp;nbsp;*/ <br />\r\npublic static Document string2Document(String s){ <br />\r\n&amp;nbsp;Document doc = null; <br />\r\n&amp;nbsp;try{ <br />\r\n&amp;nbsp;&amp;nbsp;doc = DocumentHelper.parseText(s); <br />\r\n&amp;nbsp;}<br />\r\n&amp;nbsp;catch(Exception ex){&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />\r\n&amp;nbsp;&amp;nbsp;ex.printStackTrace(); <br />\r\n&amp;nbsp;} <br />\r\n&amp;nbsp;return doc; <br />\r\n}</div>\r\n", "Photo" : "20140122/133521.jpg", "Tags" : [ "JAVA", "DOM4J", "XML" ], "Title" : "DOM4J 操作 XML", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2383 }
{ "_id" : { "$oid" : "4a235aba3816398c1de14833" }, "Bookmark" : 1, "Cate" : "插件", "Content" : "<p>以net.foreworld.rss2为例，添加一个Ctrl+N打开新窗口功能。</p>\r\n\r\n<h6>1. 在plugin.xml中添加org.eclipse.ui.commands扩展点。</h6>\r\n\r\n<div class=\"highlight\">\r\n  <pre>\r\n    <code class=\"html\"><span class=\"nt\">&lt;extension</span> <span class=\"na\">point=</span><span class=\"s\">\"org.eclipse.ui.commands\"</span><span class=\"nt\">&gt;</span>\r\n  <span class=\"nt\">&lt;category</span> <span class=\"na\">description=</span><span class=\"s\">\"Foreworld\"</span> <span class=\"na\">id=</span><span class=\"s\">\"net.foreworld.rss2.commands\"</span> <span class=\"na\">name=</span><span class=\"s\">\"Foreworld\"</span> <span class=\"nt\">/&gt;</span>\r\n  <span class=\"nt\">&lt;command</span> <span class=\"na\">categoryId=</span><span class=\"s\">\"net.foreworld.rss2.commands\"</span> <span class=\"na\">description=</span><span class=\"s\">\"打开新窗口\"</span> <span class=\"na\">id=</span><span class=\"s\">\"net.foreworld.rss2.bindings.command.open_new_window\"</span> <span class=\"na\">name=</span><span class=\"s\">\"打开新窗口\"</span> <span class=\"nt\">/&gt;</span>\r\n<span class=\"nt\">&lt;/extension&gt;</span>\r\n</code></pre></div>\r\n\r\n<h6>2. 在plugin.xml中添加org.eclipse.ui.bindings扩展点。</h6>\r\n<div class=\"highlight\">\r\n  <pre>\r\n    <code class=\"html\"><span class=\"nt\">&lt;extension</span> <span class=\"na\">point=</span><span class=\"s\">\"org.eclipse.ui.bindings\"</span><span class=\"nt\">&gt;</span>\r\n  <span class=\"nt\">&lt;scheme</span> <span class=\"na\">id=</span><span class=\"s\">\"net.foreworld.rss2.bindings\"</span> <span class=\"na\">name=</span><span class=\"s\">\"Foreworld\"</span> <span class=\"nt\">/&gt;</span>\r\n  <span class=\"nt\">&lt;key</span> <span class=\"na\">commandId=</span><span class=\"s\">\"net.foreworld.rss2.bindings.command.open_new_window\"</span> <span class=\"na\">schemeId=</span><span class=\"s\">\"net.foreworld.rss2.bindings\"</span> <span class=\"na\">sequence=</span><span class=\"s\">\"Ctrl+N\"</span> <span class=\"nt\">/&gt;</span>\r\n<span class=\"nt\">&lt;/extension&gt;</span>\r\n</code></pre></div>\r\n\r\n<h6>3. 在Action中设置全局快捷键。</h6>\r\n<div class=\"highlight\"><pre><code class=\"js\"><span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"k\">final</span> ActionFactory OPEN_NEW_WINDOW = <span class=\"k\">new</span> ActionFactory(ActionFactory.OPEN_NEW_WINDOW.getId()){\r\n  <span class=\"k\">public</span> IWorkbenchAction create(IWorkbenchWindow window) {\r\n    IWorkbenchAction action = ActionFactory.OPEN_NEW_WINDOW.create(window);\r\n    String id = <span class=\"s1\">\"net.foreworld.rss2.bindings.command.open_new_window\"</span>;\r\n    <span class=\"k\">if</span>(action != <span class=\"k\">null</span>){\r\n      action.setText(<span class=\"s1\">\"打开新窗口(&N)\"</span>);\r\n      action.setActionDefinitionId(id);\r\n    }\r\n    <span class=\"k\">return</span> action;\r\n  }\r\n};</code></pre></div>\r\n<h6>4. 在ApplicationActionBarAdvisor的makeActions()中注册该方法。</h6>\r\n<div class=\"highlight\"><pre><code class=\"js\"><span class=\"k\">this</span>.register(RSS2ActionFactory.OPEN_NEW_WINDOW.create(<span class=\"k\">this</span>.window));\r\n</code></pre></div>", "Intro" : "Eclilpse RCP 学过木有？有好几年没着过了！", "Photo" : "20140207/134411.jpg", "Tags" : [ "Eclipse", "RCP" ], "Title" : "RCP 添加全局快捷键", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 3702 }
{ "_id" : { "$oid" : "4a34462f3816398c1de14831" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<embed src=\"http://player.ku6.com/refer/-HjgUtVRieG2wTKoJSzwXQ../v.swf\" width=\"100%\" height=\"400px\"></embed>", "Intro" : "看看吧！？", "Photo" : "", "Tags" : [], "Title" : "国产动漫和日本动漫开战", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2073 }
{ "_id" : { "$oid" : "4a442c113816398c1de1482f" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>昨天整理数据，误删除了ftp上全部的文件，今天恢复了部分数据，倒霉啊，也不知道晕啥了！！！</p>", "Intro" : "昨天整理数据，误删除了ftp上全部的文件，今天恢复了部分数据，倒霉啊，也不知道晕啥了！！！", "Photo" : "", "Tags" : [], "Title" : "倒霉！！！", "Topmark" : 0, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2085 }
{ "_id" : { "$oid" : "4e16b6c53816398c1de1482d" }, "Bookmark" : 1, "Cate" : "杂文", "Content" : "<p>以管理员身份运行，可以做成bat文件放到桌面方便运行。</p>\r\n<div class=\"bs-callout bs-callout-warning\">\r\n<h4>安装：</h4>\r\n<p>D:\\software\\mysql\\mysql-5.5.11-win32\\bin>mysqld --install</p>\r\n<p>Service successfully installed.</p>\r\n</div>\r\n<div class=\"bs-callout bs-callout-info\">\r\n<h4>启动：</h4>\r\n<p>D:\\software\\mysql\\mysql-5.5.11-win32\\bin>net start mysql</p>\r\n<p>MySQL 服务正在启动 ....</p>\r\n<p>MySQL 服务已经启动成功。</p>\r\n</div>\r\n<div class=\"bs-callout bs-callout-danger\">\r\n<h4>停止：</h4>\r\n<p>D:\\software\\mysql\\mysql-5.5.11-win32\\bin>net stop mysql</p>\r\n<p>MySQL 服务正在停止.</p>\r\n<p>MySQL 服务已成功停止。</p>\r\n</div>", "Intro" : "其实大部分的win系统应该都可以这么安装的。", "Photo" : "20140122/110203.jpg", "Tags" : [ "mysql" ], "Title" : "win7 安装 mysql", "Topmark" : 1, "User_Id" : { "$oid" : "53d99f9cbf3063384388c4ea" }, "ViewCount" : 2045 }
{ "_id" : { "$oid" : "53ec723c96644458278a570e" }, "Bookmark" : 0, "Cate" : "杂文", "Content" : "<p>如题</p>", "Intro" : "如题", "Photo" : "", "Tags" : [], "Title" : "什么都是新的，测试一下吧！：）？", "Topmark" : 0, "User_Id" : { "$oid" : "53ec60b0899ae9d02ff7874b" }, "ViewCount" : 94 }
